<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ruby | VF svp]]></title>
  <link href="http://vfsvp.fr/tags/ruby/atom.xml" rel="self"/>
  <link href="http://vfsvp.fr/"/>
  <updated>2014-07-30T12:13:02+02:00</updated>
  <id>http://vfsvp.fr/</id>
  <author>
    <name><![CDATA[Simon Courtois (@simonc)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Une gem Ruby universelle en 20 lignes de code]]></title>
    <link href="http://vfsvp.fr/article/gem-universelle-en-20-lignes"/>
    <updated>2014-06-27T12:00:00+02:00</updated>
    <id>http://vfsvp.fr/article/gem-universelle-en-20-lignes</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://blog.crossplatformruby.com/universal-ruby-gems-in-20-lines-of-code">Universal Ruby Gems in 20 Lines of Code de Michal Taszycki</a></p>

<p>Les gems Ruby sont les blocs essentiels à la création d'applications Ruby Cross-Plateformes. Nous les utilisons pour encapsuler la logique de nos applications et extraire des fonctionnalités réutilisables sur différentes plateformes.</p>

<p>Je vais vous montrer comment préparer une gem Ruby pour qu'elle fonctionne avec <strong>Ruby</strong>, <strong>Opal.rb</strong> et <strong>RubyMotion</strong> sans aucune modification. De cette façon vous pourrez l'utiliser dans vos applications Rails/iOS/OSX/Android/Navigateur Client.</p>

<!-- more -->


<p>Nous avons tout d'abord besoin d'un gem d'exemple&hellip;</p>

<h2>La gem pig_latin</h2>

<p>La gem pig_latin est un simple utilitaire de traduction. Elle convertit n'importe quel mot anglais en son équivalent <a href="http://en.wikipedia.org/wiki/Pig_Latin">pig latin</a>.</p>

<p>Nous pouvons l'utiliser comme ceci :</p>

<pre><code class="ruby">PigLatin.translate("cross platform ruby")
#=&gt; "osscray atformplay ubyray"
</code></pre>

<p>La gem pig_latin est disponible sur <a href="https://github.com/crossplatformruby/pig_latin">github</a> vous pouvez donc en lire le code ou l'essayer.</p>

<p>C'est une petite gem toute bête avec laquelle on peut s'amuser. Elle a cependant un aspect qui la rend particulièrement intéressante.</p>

<p>Voyons ce qu'il se passe lorsque nous ajoutons la ligne suivante au Gemfile d'une application Rails ou RubyMotion.</p>

<pre><code class="ruby">gem 'pig_latin', git: 'git@github.com:crossplatformruby/pig_latin.git'
</code></pre>

<p>Et bien&hellip;</p>

<h2>Cela fonctionne partout !</h2>

<p>Que vous utilisiez Rails, RubyMotion ou même une application en ligne de commande, ça fonctionne tout seul. Si vous utilisez Opal.rb dans votre application, vous pouvez appeler <code>require</code> dessus et l'utiliser dans votre navigateur.</p>

<p>Essayez-la.</p>

<h3>Rails</h3>

<pre><code class="ruby">class TranslationsController &lt; ApplicationController
  def show
    @phrase = params[:phrase]
    @translation = PigLatin.translate(@phrase)
  end
end
</code></pre>

<p><img src="/images/universal_gems/rails.png" alt="Pig Latin avec Rails" /></p>

<h3>Opal.rb</h3>

<pre><code class="ruby">require "opal"
require "opal_ujs"
require "pig_latin"

puts PigLatin.translate("cross platform ruby")
</code></pre>

<p><img src="/images/universal_gems/opal.png" alt="Pig Latin dans un navigateur" /></p>

<h3>iOS</h3>

<pre><code class="ruby">class AppDelegate
  def application(application, didFinishLaunchingWithOptions:launchOptions)
    alert = UIAlertView.new
    alert.message = PigLatin.translate("cross platform ruby")
    alert.show
  end
end
</code></pre>

<p><img src="/images/universal_gems/ios.png" alt="Pig Latin sur iOS" /></p>

<h3>OSX</h3>

<pre><code class="ruby">class AppDelegate
  def applicationDidFinishLaunching(notification)
    buildMenu
    buildWindow

    alert = NSAlert.new
    alert.messageText = PigLatin.translate("cross platform ruby")
    alert.runModal
  end

  def buildWindow
    # (...) details omis pour plus de clareté
  end
end
</code></pre>

<p><img src="/images/universal_gems/osx.png" alt="Pig Latin sur OS X" /></p>

<h3>Android (bientôt)</h3>

<p>Dans les mois qui viennent, RubyMotion permettra la création d'applications Ruby pour Android. Je mettrais à jour cet article quand ce sera possible. Il semble cependant qu'aucun réglage additionnel ne sera nécessaire.</p>

<h2>Comment cela fonctionne-t-il ?</h2>

<p>Lorsque l'on parle d'écrire une gem, la principale différence entre les plateformes est la façon dont les fichiers sont appelés.</p>

<p>RubyMotion et Opal.rb ne permettent pas l'usage de <code>require</code> au runtime. Nous devons donc nous assurer que tous les fichiers de notre gem sont appelés en amont.</p>

<p>En Ruby Cross-Plateforme, le fichier faisant office de point d'entrée devient le manifeste de la gem.</p>

<h3>1. Faire fonctionner la gem avec Ruby</h3>

<p>Si votre seule plateforme est MRI ou Rubinius, votre point d'entrée, <code>pig_latin.rb</code>, doit ressembler à ceci :</p>

<pre><code class="ruby">require "pig_latin/version"
require "pig_latin/word_translator"
require "pig_latin/phrase_translator"
require "pig_latin/class_methods"
</code></pre>

<p>Aucun code spécifique à la gem ne doit être présent dans ce fichier, uniquement une suite d'appels à <code>require</code>, c'est important pour plus tard.</p>

<h3>2. Supporter Opal.rb</h3>

<p>Il est facile de faire fonctionner notre manifeste sous Opal. Collez simplement le code ci-dessous n'importe où dans <code>pig_latin.rb</code>.</p>

<pre><code class="ruby">if defined?(Opal) &amp;&amp; defined?(File)
  Opal.append_path File.expand_path('.', File.dirname(__FILE__))
end
</code></pre>

<p>Il est plus difficile de comprendre pourquoi ça fonctionne.</p>

<p>Lorsque Opal compile les fichiers, il transforme les appels à <code>require</code> en directives <code>Sprockets</code>. Cela veut dire qu'au moment où l'on appelle <code>application.rb</code>, il comprend les <code>require</code> mais ne sait pas où trouver les fichiers.</p>

<p>C'est pour cette raison que nous devons ajouter le chemin du dossier contenant notre point d'entrée grâce à <code>Opal#append_path</code>.</p>

<p>Cela veut dire que notre manifeste est lancé deux fois :</p>

<ol>
<li>En Ruby, lorsque la gem est appelée pour informer Opal des chemins à charger ;</li>
<li>En Opal.rb pour traduire les <code>require</code> en directives <code>Sprockets</code>.</li>
</ol>


<h3>3. Compiler pour RubyMotion</h3>

<p>RubyMotion ne permet pas d'appeler <code>require</code> au runtime. Nous devons donc lui fournir la liste des fichiers à compiler. Il serait cependant plus intéressant de conserver notre succession de <code>require</code> et de nous en servir pour générer cette liste.</p>

<p>Puisque notre manifeste est lancé avec Ruby, nous pouvons le faire en utilisant la technique suivante.</p>

<p>Commençons par redéfinir la méthode <code>require</code> :</p>

<pre><code class="ruby">if defined?(Motion::Project::Config)
  def rubymotion_require(filename)
    @files_to_require ||= []
    @files_to_require &lt;&lt; filename
  end

  alias :old_require :require
  alias :require :rubymotion_require
end
</code></pre>

<p>Nous appelons ensuite <code>require</code> comme d'habitude.</p>

<p>Pour finir, nous construisons la liste des fichiers à compiler et remettons <code>require</code> en place une fois terminé.</p>

<pre><code class="ruby">if defined?(Motion::Project::Config)
  alias :require :old_require

  Motion::Project::App.setup do |app|
    paths_to_require = @files_to_require.map do |file|
      File.join(File.dirname(__FILE__), file + ".rb")
    end

    app.files.unshift(*paths_to_require)
  end
end
</code></pre>

<h2>En résumé</h2>

<p>En utilisant quelques astuces et une organisation intelligente des fichiers, nous avons réussi à créer une gem qui fonctionne sur les serveurs, dans les applications lourdes, dans les navigateurs et sur mobiles. Cela permet de partager du code entre plusieurs applications.</p>

<p>Vous pouvez très facilement adapter ces techniques à vos propres gems. Cela prend littéralement 20 lignes de code pour les rendre universelles.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tri de dépendances en Ruby avec TSort]]></title>
    <link href="http://vfsvp.fr/article/dependency-sorting-in-ruby-with-tsort"/>
    <updated>2014-03-27T16:00:00+01:00</updated>
    <id>http://vfsvp.fr/article/dependency-sorting-in-ruby-with-tsort</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://viget.com/extend/dependency-sorting-in-ruby-with-tsort">Dependency Sorting in Ruby with TSort de Lawson Kurtz sur le blog de Viget</a></p>

<p>Si vous utilisez Ruby, vous avez probablement eu l'occasion d'expérimenter les
miracles de la gestion de dépendances de <a href="http://bundler.io/">{l-en Bundler}</a>.
Ce que vous ne savez peut-être pas, c'est que vous pouvez utiliser les mêmes
mécanismes de tri de dépendances dans vos propres applications et dans d'autres
contextes.</p>

<!-- more -->


<h2>Hello TSort</h2>

<p><a href="http://www.ruby-doc.org/stdlib-2.0/libdoc/tsort/rdoc/TSort.html">{l-en TSort}</a>
est un module Ruby, disponible dans la bibliothèque standard, qui permet de
faire du <a href="http://fr.wikipedia.org/wiki/Tri_topologique">tri topologique</a>.
{l-en Bundler} utilise {l-en TSort} pour démêler le sac de nœuds de dépendances
de vos {l-en gems}. La gestion de ces dépendances est la partie émergée de
l'iceberg en ce qui concerne les possibilités du tri topologique. Il est assez
facile de profiter de l'incroyable puissance de {l-en TSort} dans votre projet.</p>

<h2>Use Case : Ajouter des données d'exemple dans un base de données</h2>

<p>Imaginons une tâche qui doit peupler une base de données avec plusieurs
enregistrements. Mais rien n'est jamais facile, nos enregistrements ont des
dépendances comme le montre l'exemple ci-dessous :</p>

<pre><code class="ruby">user_1 = User.create address: address_1

school_1 = School.create address: address_2, faculty: [user_1]
school_2 = School.create address: address_3

address_1 = Address.create zip_code: zip_code_1
address_2 = Address.create zip_code: zip_code_2
address_3 = Address.create zip_code: zip_code_2

zip_code_1 = ZipCode.create
zip_code_2 = ZipCode.create
</code></pre>

<h3>Le problème</h3>

<p>Si on lance le pseudo-code précédent, il va bien sûr lever une exception
<code>NameError</code> puisque plusieurs enregistrements en référencent d'autres qui ne
sont pas encore créés.</p>

<p>Pour cet exemple simpliste, il serait facile de trier les lignes à la main, pour
que les insertions aient lieu dans le bon ordre. Mais comment faire quand les
relations dépendantes sont plus complexes ou quand le nombre d'enregistrements
est tout simplement trop important ? Trier à la main n'est simplement pas
envisageable (qui aime faire les choses à la main de toute façon ?).</p>

<h3>La solution</h3>

<p>C'est ici que {l-en TSort} entre en scène. Nous pouvons l'utiliser pour
déterminer l'ordre dans lequel ces enregistrements doivent être insérés.</p>

<p>La façon la plus rapide d'utiliser {l-en TSort} est de créer puis trier un
{l-en hash} dans lequel chaque clé représente un objet et chaque valeur est un
tableau de références aux objets dont l'objet-clé dépend.</p>

<p>Si <code>skier</code> dépend de <code>neige</code> et <code>neige</code> dépend de <code>nuages</code> et <code>froid</code>, notre
{l-en hash} va ressembler à ceci :</p>

<pre><code class="ruby">{
  'nuages' =&gt; [],
  'froid'  =&gt; [],
  'skier'  =&gt; ['neige'],
  'neige'  =&gt; ['nuages', 'froid']
}
</code></pre>

<p>Nous listons seulement les dépendances de premier niveau, {l-en TSort} se
débrouillera tout seul pour déterminer le reste.</p>

<p>Pour faire un tri topologique sur ce {l-en hash} de dépendances, il nous faut
quelques fonctionnalités de {l-en TSort}. Le plus simple est de créer une classe
qui hérite de {l-en Hash} comme ceci :</p>

<pre><code class="ruby">require 'tsort'

class TsortableHash &lt; Hash
  include TSort

  alias tsort_each_node each_key

  def tsort_each_child(node, &amp;block)
    fetch(node).each(&amp;block)
  end
end
</code></pre>

<p>Nous pouvons maintenant utiliser notre classe pour construire le {l-en hash} de
dépendances. Pour nos enregistrements du début, il va ressembler à ceci :</p>

<pre><code class="ruby">dependency_hash = \
TsortableHash[
  user_1     =&gt; [address_1],
  school_1   =&gt; [address_2, user_1],
  school_2   =&gt; [address_3],
  address_1  =&gt; [zip_code_1],
  address_2  =&gt; [zip_code_2],
  address_3  =&gt; [zip_code_2],
  zip_code_1 =&gt; [],
  zip_code_2 =&gt; []
]
</code></pre>

<p>Une fois notre {l-en hash} de dépendances {l-en tsortable} créé, le plus dur
est fait. {l-en TSort} s'occupe du reste et nous donne un tableau ordonné qu'il
nous suffit de suivre pour insérer les enregistrements sans problème.</p>

<pre><code class="ruby">dependency_hash.tsort
#=&gt; [zip_code_1, address_1, user_1, zip_code_2, address_2, school_1, address_3, school_2]

# Si vous avez des dépendances circulaires, #tsort lèvera une exception TSort::Cyclic.
</code></pre>

<p>{l-en TSort} est un outil incroyablement puissant et simple pour ordonner des
relations dépendantes. La prochaine fois que vous avez du mal à gérer des
dépendances, rassurez-vous,
<a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/tsort/rdoc/TSort.html">TSort</a> est
disponible en un clic.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guide de migration vers Capistrano 3]]></title>
    <link href="http://vfsvp.fr/article/guide-de-migration-vers-capistrano-3"/>
    <updated>2014-01-13T11:05:00+01:00</updated>
    <id>http://vfsvp.fr/article/guide-de-migration-vers-capistrano-3</id>
    <content type="html"><![CDATA[<p>Source: <a href="https://semaphoreapp.com/blog/2013/11/26/capistrano-3-upgrade-guide.html">Capistrano 3 Upgrade Guide de Darko Fabijan sur le blog de Semaphore </a></p>

<p>Nous avons récemment reçu des demandes de support pour Capistrano 3. Pour
fournir un service de support de qualité, il faut connaitre le sujet, je me suis
donc lancé dans la quête de migrer scripts de déploiement de Capistrano 2 à
Capistrano 3. Comme toujours, cela a pris un peu plus de temps que prévu mais au
final le code est plus propre.</p>

<p>Je dois dire que j'ai eu un flashback remontant à deux ans, lorsque je mettais
en place Capistrano pour la première fois : la documentation est incomplète
et il faut jongler entre le
<a href="https://github.com/capistrano/capistrano">{l-en readme}</a>,
le <a href="https://github.com/capistrano/capistrano/wiki">wiki</a> et
<a href="http://www.capistranorb.com/">la page d'accueil officielle</a>. Mais c'est un
projet open-source et les participations pour améliorer cela sont les
bienvenues.</p>

<p>Je vais tenter de vous faciliter la migration en vous montrant notre nouvelle
configuration en parallèle de l'ancienne, étape par étape.</p>

<!-- more -->


<h2>Mettre en place la nouvelle configuration</h2>

<h3>Gemfile</h3>

<p>La première étape est d'installer de nouvelles gems. Capistrano 2 ne supportait
pas les configurations {l-en multistage}, il fallait pour cela
utiliser la gem <code>capistrano-ext</code>. Capistrano 3 supporte le
{l-en multistage} en standard. Il est indépendant de tout {l-en framework},
vous devez donc utiliser <code>capistrano-rails</code> si vous comptez déployer une
application {l-en Rails}. Suivez l'exemple ci-dessous pour mettre votre
{l-en Gemfile} à jour, lancez ensuite <code>bundle install</code> et vous êtes prêt pour la
migration.</p>

<p>Capistrano 2 :</p>

<pre><code class="ruby">group :development do
  gem "capistrano"
  gem "capistrano-ext"
end
</code></pre>

<p>Capistrano 3 :</p>

<pre><code class="ruby">group :development do
  gem "capistrano-rails"
end
</code></pre>

<h3>Ajouter Capistrano 3 à votre projet</h3>

<p>Comme le conseille
<a href="http://www.capistranorb.com/documentation/upgrading/">le guide officiel de mise à jour</a>,
il est préférable de copier les anciens fichiers Capistrano dans un endroit sûr,
au cas où, et d'ajouter les nouveaux fichiers générés à la main. Voici une
astuce pour le faire :</p>

<pre><code class="ruby">mkdir old_cap
mv Capfile old_cap
mv config/deploy.rb old_cap
mv config/deploy/ old_cap
</code></pre>

<p>Une fois cela fait, vous êtes prêt à mettre le nouveau Capistrano en place pour
votre projet :</p>

<pre><code>bundle exec cap install
</code></pre>

<h2>Capfile</h2>

<p>Parmi les fichiers fraichement générés, vous devriez trouver le nouveau
{l-en Capfile}. Ci-dessous, l'ancienne version de notre {l-en Capfile} suivie
de la nouvelle :</p>

<p>Capistrano 2 :</p>

<pre><code class="ruby">load "deploy"
load "deploy/assets"
Dir["vendor/gems/*/recipes/*.rb","vendor/plugins/*/recipes/*.rb"].each { |plugin| load(plugin) }
load "config/deploy"
</code></pre>

<p>Capistrano 3 :</p>

<pre><code class="ruby">require "capistrano/setup"
require "capistrano/deploy"

require "capistrano/bundler"
require "capistrano/rails/assets"
require "capistrano/rails/migrations"
require "whenever/capistrano"

Dir.glob("lib/capistrano/tasks/*.cap").each { |r| import r }
</code></pre>

<p>Votre nouveau {l-en Capfile} va contenir deux lignes commentées à propos du
support pour <code>rvm</code> et <code>rbenv</code>. Nous n'utilisons ni l'un ni l'autre pour gérer
Ruby sur nos serveurs je ne peux pas donc vous en dire long sur le sujet.</p>

<pre><code class="ruby">require "capistrano/rvm"
require "capistrano/rbenv"
</code></pre>

<h2>Configuration multistage</h2>

<p>Comme vous pouvez le voir ci-dessous, la configurations des {l-en stages} ne
change pas vraiment. Il y a cependant une chose à laquelle vous devez prêter
particulièrement attention. La façon de signifier à Capistrano une révision à
déployer a changé. Si vous faites du déploiement continu avec Capistrano, vous
avez probablement déjà vu la ligne suivante :</p>

<pre><code>bundle exec cap -S revision=$REVISION production deploy
</code></pre>

<p><code>REVISION</code> est une variable d'environnement que Semaphore exporte durant le
déploiement et Capistrano 2 l'utilisait comme paramètre. Avec Capistrano 3, cela
n'est plus possible et vous devez donner à la variable <code>branch</code> la révision ou
la branche que vous souhaitez déployer. Il était déjà possible de spécifier une
branche en configuration :</p>

<pre><code class="ruby">set :branch, ENV["BRANCH_NAME"] || "master"
</code></pre>

<p>Il nous suffit donc d'ajouter <code>ENV["REVISION"]</code> à la liste.</p>

<pre><code class="ruby">set :branch, ENV["REVISION"] || ENV["BRANCH_NAME"] || "master"
</code></pre>

<p>Cela fait partie des choses non documentées et il faut fouiller les sources ou
poser la question pour le savoir. L'un dans l'autre, le changement est assez
simple.</p>

<p>Le fichier suivant est notre <code>config/deploy/production.rb</code>.</p>

<p>Capistrano 2 :</p>

<pre><code class="ruby">server "server1.example.com", :app, :web, :db, :primary =&gt; true, :jobs =&gt; true
server "server2.example.com", :app, :web, :jobs =&gt; true

set :branch, ENV["BRANCH_NAME"] || "master"
</code></pre>

<p>Capistrano 3 :</p>

<pre><code class="ruby">set :stage, :production

server "server1.example.com", user: "deploy_user", roles: %w{web app db}
server "server2.example.com", user: "deploy_user", roles: %w{web app}

set :branch, ENV["REVISION"] || ENV["BRANCH_NAME"] || "master"
</code></pre>

<h2>Configuration principale - <code>config/deploy.rb</code></h2>

<p>C'est ici que les plus gros changements auront lieu. Voici ce à quoi il faut
faire attention :</p>

<ol>
<li>Vous n'avez plus besoin d'appeler <code>capistrano/ext/multistage</code> ou
<code>bundler/capistrano</code>. Le {l-en multistage} est supporté en standard et le
support de Bundler est fait dans le fichier Capfile.</li>
<li>Il n'est pas nécessaire de lister les {l-en stages} disponible ou celui par
défaut.</li>
<li>La variable pour régler l'url de dépôt source a changé de <code>repository</code> à
<code>repo_url</code>.</li>
<li><code>deploy_via :remote_cache</code> n'est plus nécessaire. La façon dont Capistrano
gère les dépôts a beaucoup changé, il maintient maintenant un mirroir du
dépôt sur votre serveur.</li>
<li>L'option PTY est activée par défaut.</li>
<li><code>ssh_options</code> a un peu changé je crois mais les réglages de base sont à peu
près les mêmes.</li>
<li>Capistrano prend maintenant en charge les liens symboliques dont vous avez
besoin. Il vous suffit de lui dire de parcourir <code>linked_files</code> and
<code>linked_dirs</code>.</li>
<li>Si vous n'utilisez ni <code>rvm</code> ni <code>rbenv</code>, vous devez surcharger les commandes
<code>rake</code> et <code>rails</code> (voyez le fichier deploy.rb de Capistrano 3).</li>
</ol>


<p>L'écriture de {l-en tasks} a également changé et il est nécessaire de fouiller
la documentation pour écrire ce que vous voulez. La bibliothèque utilisée en
dessous est <a href="https://github.com/capistrano/sshkit">SSHKit</a> qui semble bien
sympathique.</p>

<p><strong>Astuce :</strong> avec Capistrano 2 vous pouviez écrire <code>var_name</code> et obtenir sa
valeur. Avec la nouvelle version, vous devez toujours utiliser
<code>fetch(:var_name)</code>. Il m'a fallut un certain temps pour le comprendre alors que
je reprenais une {l-en task} que l'on utilise pour gérer nos {l-en workers}.</p>

<p>Capistrano 2 :</p>

<pre><code class="ruby">require "capistrano/ext/multistage" #1
require "bundler/capistrano"

set :application, "webapp"
set :stages, %w(production staging)
set :default_stage, "staging" #2

set :scm, :git
set :repository,  "git@github.com:example/webapp.git" #3
set :deploy_to, "/home/deploy_user/webapp"
set :deploy_via, :remote_cache #4

default_run_options[:pty] = true #5
set :user, "deploy_user"
set :use_sudo, false

ssh_options[:forward_agent] = true #6
ssh_options[:port] = 3456

set :keep_releases, 20

namespace :deploy do

  desc "Restart application"
  task :restart, :roles =&gt; :app, :except =&gt; { :no_release =&gt; true } do
    run "#{try_sudo} touch #{File.join(current_path,'tmp','restart.txt')}"
  end

  desc "Prepare our symlinks" #7
  task :post_symlink, :roles =&gt; :app, :except =&gt; { :no_release =&gt; true } do
    ["config/database.yml", "config/config.yml"].each do |path|
      run "ln -fs #{shared_path}/#{path} #{release_path}/#{path}"
    end
  end

end

after  "deploy",                   "deploy:post_symlink"
after  "deploy:restart",           "deploy:cleanup"
before "deploy:assets:precompile", "deploy:post_symlink"
</code></pre>

<p>Capistrano 3 :</p>

<pre><code class="ruby">set :application, "webapp"

set :scm, :git
set :repo_url,  "git@github.com:example/webapp.git"
set :deploy_to, "/home/deploy_user/webapp"

set :ssh_options, {
  forward_agent: true,
  port: 3456
}

set :log_level, :info

set :linked_files, %w{config/database.yml config/config.yml}
set :linked_dirs, %w{bin log tmp vendor/bundle public/system}

SSHKit.config.command_map[:rake]  = "bundle exec rake" #8
SSHKit.config.command_map[:rails] = "bundle exec rails"

set :keep_releases, 20

namespace :deploy do

  desc "Restart application"
  task :restart do
    on roles(:app), in: :sequence, wait: 5 do
      execute :touch, release_path.join("tmp/restart.txt")
    end
  end

  after :finishing, "deploy:cleanup"

end
</code></pre>

<h2>Conclusion</h2>

<p>Le code que vous obtenez au final et plus propre et Capistrano 3/SSHKit semble
un mélange puissant. Quoi qu'il en soit, certaines bibliothèques comme
<code>whenever</code> et <code>bugsnag</code> ne supportent pas encore Capistrano 3, vous devrez donc
écrire leurs règles vous-même.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir pour les rubyists (partie 2)]]></title>
    <link href="http://vfsvp.fr/article/elixir-pour-les-rubyists-2"/>
    <updated>2013-10-29T21:00:00+01:00</updated>
    <id>http://vfsvp.fr/article/elixir-pour-les-rubyists-2</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.natescottwest.com/blog/2013/10/09/elixir-for-rubyists-part-2/">Elixir for Rubyists part 2 par Nate West</a></p>

<p>Voici une tentative de réponse aux questions de la <a href="/article/elixir-pour-les-rubyists-1">partie 1</a>.</p>

<h2>Immuable ??</h2>

<p>Les variables d'Elixir sont immuables. Elles ne sont pas à assignation unique.
Je vous entends déjà dire &ldquo;Mais Nate ! Si on réassigne une variable, n'est-ce
pas une mutation ?&rdquo;. Non !</p>

<h2>Elixir assure la transparence référentielle des variables</h2>

<p>Transparence référentielle est une façon académique de dire &ldquo;quand je fais
quelque chose qui modifie une valeur, je peux toujours revenir à la valeur
originale&rdquo;. Jessica Kerr (<a href="https://twitter.com/jessitron">@jessitron</a>) appelle
cela &ldquo;données en entrée, données en sortie&rdquo; (<em>data in, data out</em>). Sous forme
de code :</p>

<!-- more -->


<pre><code class="elixir">name = "Nate"
# =&gt; "Nate"
String.upcase(name)
# =&gt; "NATE"
name
# =&gt; "Nate"
</code></pre>

<p><code>String.upcase</code> est référentiellement transparent. Il retourne une nouvelle
valeur transformée mais ne modifie pas la valeur originale. On peut comparer
cela avec <code>String#upcase!</code> en Ruby.</p>

<pre><code class="ruby">name = "Nate"
# =&gt; "Nate"
name.upcase!
# =&gt; "NATE"
name
# =&gt; "NATE"
</code></pre>

<p><code>String#upcase!</code> <em>n'est pas</em> référentiellement transparent. Non seulement il
retourne une valeur transformée mais modifie également la valeur originale.</p>

<p>Avec Elixir, dans le contexte d'une fonction vous ne pourrez pas modifier la
valeur d'une variable.</p>

<pre><code class="elixir">name = "Nate"
# =&gt; "Nate"
capitalize = fn(string) -&gt; string = String.upcase(string) end
# =&gt; #Function&lt;6.80484245 in :erl_eval.expr/5&gt;
capitalize.(name)
# =&gt; "NATE"
name
# =&gt; "Nate"
</code></pre>

<h2>En quoi la transparence référentielle est importante ?</h2>

<p>Pour faire court, un code référentiellement transparent est simple à tester,
facile à comprendre et à rendre <em>threadsafe</em>. Si on a ceci en Ruby :</p>

<pre><code class="elixir">greeting = "Hello"
do_something_to_string(greeting)
print(greeting)
</code></pre>

<p>On s'attend à ce que <code>greeting</code> ait la valeur &ldquo;Hello&rdquo; lorsque l'on appelle
<code>print</code> mais <code>do_something_to_string</code> a pu modifier la valeur de <code>greeting</code>.
D'autant plus si <code>greeting</code> est transmis un peu partout dans l'application et
passe par toutes sortes de <code>do_somethings</code>. Au moment d'afficher <code>greeting</code>, il
pourrait tout aussi bien contenir &ldquo;Game over !&rdquo;.</p>

<p>Pour en savoir plus :</p>

<ul>
<li><a href="http://confreaks.com/videos/2382-rmw2013-functional-principles-for-oo-development">Jessica Kerr’s Functional Principles (en)</a></li>
<li><a href="http://rubyrogues.com/115-rr-functional-and-object-oriented-programming-with-jessica-kerr/">Ruby Rogues Podcast: Functional and OO Programming (en)</a></li>
<li>Si vous pensez à d'autres ressources, dites le moi, je les ajouterai.</li>
</ul>


<h2>Un piège&hellip;</h2>

<p>Il est possible d'assigner une nouvelle valeur à une variable en se basant sur
sa valeur actuelle. Notez bien qu'ici <code>=</code> n'est pas un opérateur d'assignation.
C'est un opérateur de test de correspondance. Lorsque l'on utilise sur une
variable, on peut choisir de tester la valeur de la variable ou nous pouvons
l'autoriser à prendre une nouvelle valeur.</p>

<pre><code class="elixir">1 = 2 # la valeur 1 ne correspond pas à la valeur 2
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3

:a = 2 # la valeur :a, un atôme (un peu comme un symbole en Ruby),
       # ne correspond pas à la valeur 2
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3

num = 2 # num est une variable. Nous pouvons lui assigner 2 pour établir
        # une correspondance.
# =&gt; 2

^num = 3 # la valeur de num (2) ne correspond pas à la valeur 3
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3

num = 3 # ici on ne cherche pas de correspondance, on peut donc assigner la
        # valeur 3 à num
# =&gt; 3
</code></pre>

<p>Tel que je le comprends, cela fait parti d'Elixir pour des questions pratique
et est particulièrement utile pour écrire des macros. Les puristes de la
programmation fonctionnelle vont détester ça. Si c'est votre cas, vous pouvez
lire <a href="https://groups.google.com/forum/#!searchin/elixir-lang-core/single$20assignment/elixir-lang-core/FrK7MQGuqWc/2aimbHDAAHMJ">cette discussion</a>
au sujet de la réassignation de variables dans Elixir et jeter un oeil au
commentaire de Joe Armstrong.</p>

<p>Encore une fois, cela ne change pas l'état de l'objet. Il n'y a pas d'objet dans
Elixir. <code>num</code> est un simple conteneur de données auquel vous pouvez donner une
nouvelle valeur. Lorsque vous le faites, l'ancienne valeur va être retirée du
contexte d'exécution afin de laisser la place libre pour stocker une nouvelle
valeur.</p>

<h2>Essayez donc de le briser</h2>

<p>Vous aurez tout de même beaucoup de mal à écrire une fonction qui brise la
transparence référentielle. Si vous réassignez une variable dans une fonction,
vous ne changez sa valeur que pour le contexte de cette fonction.</p>

<pre><code class="elixir">defmodule Assignment do
  def change_me(string) do
    string = 2
  end
end

# lorsque vous compilez ce module, vous aurez un warning indiquant
# qu'une variable de type string n'est pas utilisée!

greeting = "Hi"
# =&gt; "Hi"
Assignment.change_me(greeting)
# =&gt; 2
greeting
# =&gt; "Hi"
</code></pre>

<h2>C'est tout pour aujourd'hui</h2>

<p>Voici la fin de la partie 2. À bientôt pour la partie 3.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir pour les rubyists (partie 1)]]></title>
    <link href="http://vfsvp.fr/article/elixir-pour-les-rubyists-1"/>
    <updated>2013-10-27T18:30:00+01:00</updated>
    <id>http://vfsvp.fr/article/elixir-pour-les-rubyists-1</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.natescottwest.com/blog/2013/09/26/elixir-for-rubyists/">Elixir for Rubyists part 1 par Nate West</a></p>

<p>Elixir est mon nouveau langage préféré. Cet article est le premier d'une série
de longueur indéterminée sur Elixir. En tant que rubyist, la syntaxe d'Elixir va
vous sembler familière. Je vais donc vous montrer beaucoup de code pour
vous expliquer comment il marche. Elixir est fonctionnel et amusant
(FUNctional).</p>

<p>Elixir est un langage fonctionnel qui tourne sur la VM Erlang mais ressemble
beaucoup à Ruby.</p>

<!-- more -->


<pre><code class="elixir">2 + 2
# =&gt; 4

IO.puts "Hello!"
# =&gt; Hello!
#    :ok

String.downcase("JE NE CRIE PAS")
# =&gt; "je ne crie pas"

defmodule Numbers do
  def add_to(num) do
    if is_number(num) do
      num + 2
    else
      raise(ArgumenError, message: "L'argument doit etre un nombre")
    end
  end
end

Numbers.add_to(4)
# =&gt; 6
Numbers.add_to("Nate")
# =&gt; ** (ArgumenError) L'argument doit etre un nombre
</code></pre>

<p>Elixir utilise la détection par motif (<em>pattern matching</em>) pour effectuer des
comparaisons et assigner des valeurs aux variables.</p>

<pre><code class="elixir">a = 2
# =&gt; 2

2 = a
# =&gt; 2

{ success, string } = { :ok, "Hey Joe, tu sais quoi ?" }
# =&gt; {:ok, "Hey Joe, tu sais quoi ?"}
success
# =&gt; :ok
string
# =&gt; "Hey Joe, tu sais quoi ?"
</code></pre>

<p>Elixir est fonctionnel, les variables sont donc immuables. Cependant,
contrairement à Erlang, ces dernières ne sont pas limitées à une seule
assignation. Si vous voulez détecter le motif de la valeur d'une variable, vous
devez utiliser un circonflexe <code>^</code>. Sans le circonflexe vous pouvez assigner une
nouvelle valeur à la variable.</p>

<pre><code class="elixir">a = 2
# =&gt; 2
^a = 3
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3
a = 3
# =&gt; 3
</code></pre>

<p>Comme tout langage fonctionnel, Elixir traite les fonctions comme des citoyens
de premier ordre. Vous pouvez assigner une fonction à une variable pour une
évaluation différée. Notez l'interpolation de chaîne dans l'exemple suivant,
une autre ressemblance à Ruby.</p>

<pre><code class="elixir">greeter = fn (name) -&gt; IO.puts "Hello #{name}" end
# =&gt; #Function&lt;6.80484245 in :erl_eval.expr/5&gt;
greeter.("Nate")
# =&gt; Hello Nate
#    :ok
</code></pre>

<p>Vous pouvez écrire des fonctions qui retournent des fonctions.</p>

<pre><code class="elixir">defmodule FunctionExamples do
  def build_greeter(kind) do
    case kind do
      :hello -&gt; fn (name) -&gt; "Coucou, #{name}!" end
      :goodbye -&gt; fn (name) -&gt; "A plus, #{name}!" end
      _ -&gt; fn (name) -&gt; "Je ne sais pas quoi te dire, #{name}." end
    end
  end
end

say_hello = FunctionExamples.build_greeter(:hello)
# =&gt; #Function&lt;0.63189797 in FunctionExamples.build_greeter/1&gt;
say_hello.("Nate")
# =&gt; Coucou, Nate!
#    :ok

wat = FunctionExamples.build_greeter(:something_else)
# =&gt; #Function&lt;2.63189797 in FunctionExamples.build_greeter/1&gt;
wat.("Nate")
# =&gt; "Je ne sais pas quoi te dire, Nate."
#    :ok
</code></pre>

<p>Comme dans d'autres langages fonctionnels, plutôt que de reposer sur des
boucles, Elixir utilise énormément la récursivité. Cela dit, le module <code>Enum</code>
fournit quelques fonctions bien connues des rubyists, comme <code>each</code> par exemple.</p>

<pre><code class="elixir">Enum.each(["Joe", "Matz", "Jose"], fn (name) -&gt; IO.puts(name) end)
# =&gt; Joe
# =&gt; Matz
# =&gt; Jose
# =&gt; :ok

defmodule RecursionExamples do
  def recurse([]) do
    :ok
  end
  def recurse([head|tail]) do
    IO.puts head
    recurse(tail)
  end
end

RecursionExamples.recurse(["Joe", "Matz", "Jose"])
# =&gt; Joe
# =&gt; Matz
# =&gt; Jose
# =&gt; :ok
</code></pre>

<p>C'est tout pour cette première partie. À bientôt pour <a href="/article/elixir-pour-les-rubyists-2">la deuxième</a>.</p>
]]></content>
  </entry>
  
</feed>
