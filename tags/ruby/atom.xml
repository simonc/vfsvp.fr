<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ruby | VF svp]]></title>
  <link href="http://vfsvp.fr/tags/ruby/atom.xml" rel="self"/>
  <link href="http://vfsvp.fr/"/>
  <updated>2014-06-23T20:05:58+02:00</updated>
  <id>http://vfsvp.fr/</id>
  <author>
    <name><![CDATA[Simon Courtois (@simonc)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tri de dépendances en Ruby avec TSort]]></title>
    <link href="http://vfsvp.fr/article/dependency-sorting-in-ruby-with-tsort"/>
    <updated>2014-03-27T16:00:00+01:00</updated>
    <id>http://vfsvp.fr/article/dependency-sorting-in-ruby-with-tsort</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://viget.com/extend/dependency-sorting-in-ruby-with-tsort">Dependency Sorting in Ruby with TSort de Lawson Kurtz sur le blog de Viget</a></p>

<p>Si vous utilisez Ruby, vous avez probablement eu l'occasion d'expérimenter les
miracles de la gestion de dépendances de <a href="http://bundler.io/">{l-en Bundler}</a>.
Ce que vous ne savez peut-être pas, c'est que vous pouvez utiliser les mêmes
mécanismes de tri de dépendances dans vos propres applications et dans d'autres
contextes.</p>

<!-- more -->


<h2>Hello TSort</h2>

<p><a href="http://www.ruby-doc.org/stdlib-2.0/libdoc/tsort/rdoc/TSort.html">{l-en TSort}</a>
est un module Ruby, disponible dans la bibliothèque standard, qui permet de
faire du <a href="http://fr.wikipedia.org/wiki/Tri_topologique">tri topologique</a>.
{l-en Bundler} utilise {l-en TSort} pour démêler le sac de nœuds de dépendances
de vos {l-en gems}. La gestion de ces dépendances est la partie émergée de
l'iceberg en ce qui concerne les possibilités du tri topologique. Il est assez
facile de profiter de l'incroyable puissance de {l-en TSort} dans votre projet.</p>

<h2>Use Case : Ajouter des données d'exemple dans un base de données</h2>

<p>Imaginons une tâche qui doit peupler une base de données avec plusieurs
enregistrements. Mais rien n'est jamais facile, nos enregistrements ont des
dépendances comme le montre l'exemple ci-dessous :</p>

<pre><code class="ruby">user_1 = User.create address: address_1

school_1 = School.create address: address_2, faculty: [user_1]
school_2 = School.create address: address_3

address_1 = Address.create zip_code: zip_code_1
address_2 = Address.create zip_code: zip_code_2
address_3 = Address.create zip_code: zip_code_2

zip_code_1 = ZipCode.create
zip_code_2 = ZipCode.create
</code></pre>

<h3>Le problème</h3>

<p>Si on lance le pseudo-code précédent, il va bien sûr lever une exception
<code>NameError</code> puisque plusieurs enregistrements en référencent d'autres qui ne
sont pas encore créés.</p>

<p>Pour cet exemple simpliste, il serait facile de trier les lignes à la main, pour
que les insertions aient lieu dans le bon ordre. Mais comment faire quand les
relations dépendantes sont plus complexes ou quand le nombre d'enregistrements
est tout simplement trop important ? Trier à la main n'est simplement pas
envisageable (qui aime faire les choses à la main de toute façon ?).</p>

<h3>La solution</h3>

<p>C'est ici que {l-en TSort} entre en scène. Nous pouvons l'utiliser pour
déterminer l'ordre dans lequel ces enregistrements doivent être insérés.</p>

<p>La façon la plus rapide d'utiliser {l-en TSort} est de créer puis trier un
{l-en hash} dans lequel chaque clé représente un objet et chaque valeur est un
tableau de références aux objets dont l'objet-clé dépend.</p>

<p>Si <code>skier</code> dépend de <code>neige</code> et <code>neige</code> dépend de <code>nuages</code> et <code>froid</code>, notre
{l-en hash} va ressembler à ceci :</p>

<pre><code class="ruby">{
  'nuages' =&gt; [],
  'froid'  =&gt; [],
  'skier'  =&gt; ['neige'],
  'neige'  =&gt; ['nuages', 'froid']
}
</code></pre>

<p>Nous listons seulement les dépendances de premier niveau, {l-en TSort} se
débrouillera tout seul pour déterminer le reste.</p>

<p>Pour faire un tri topologique sur ce {l-en hash} de dépendances, il nous faut
quelques fonctionnalités de {l-en TSort}. Le plus simple est de créer une classe
qui hérite de {l-en Hash} comme ceci :</p>

<pre><code class="ruby">require 'tsort'

class TsortableHash &lt; Hash
  include TSort

  alias tsort_each_node each_key

  def tsort_each_child(node, &amp;block)
    fetch(node).each(&amp;block)
  end
end
</code></pre>

<p>Nous pouvons maintenant utiliser notre classe pour construire le {l-en hash} de
dépendances. Pour nos enregistrements du début, il va ressembler à ceci :</p>

<pre><code class="ruby">dependency_hash = \
TsortableHash[
  user_1     =&gt; [address_1],
  school_1   =&gt; [address_2, user_1],
  school_2   =&gt; [address_3],
  address_1  =&gt; [zip_code_1],
  address_2  =&gt; [zip_code_2],
  address_3  =&gt; [zip_code_2],
  zip_code_1 =&gt; [],
  zip_code_2 =&gt; []
]
</code></pre>

<p>Une fois notre {l-en hash} de dépendances {l-en tsortable} créé, le plus dur
est fait. {l-en TSort} s'occupe du reste et nous donne un tableau ordonné qu'il
nous suffit de suivre pour insérer les enregistrements sans problème.</p>

<pre><code class="ruby">dependency_hash.tsort
#=&gt; [zip_code_1, address_1, user_1, zip_code_2, address_2, school_1, address_3, school_2]

# Si vous avez des dépendances circulaires, #tsort lèvera une exception TSort::Cyclic.
</code></pre>

<p>{l-en TSort} est un outil incroyablement puissant et simple pour ordonner des
relations dépendantes. La prochaine fois que vous avez du mal à gérer des
dépendances, rassurez-vous,
<a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/tsort/rdoc/TSort.html">TSort</a> est
disponible en un clic.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guide de migration vers Capistrano 3]]></title>
    <link href="http://vfsvp.fr/article/guide-de-migration-vers-capistrano-3"/>
    <updated>2014-01-13T11:05:00+01:00</updated>
    <id>http://vfsvp.fr/article/guide-de-migration-vers-capistrano-3</id>
    <content type="html"><![CDATA[<p>Source: <a href="https://semaphoreapp.com/blog/2013/11/26/capistrano-3-upgrade-guide.html">Capistrano 3 Upgrade Guide de Darko Fabijan sur le blog de Semaphore </a></p>

<p>Nous avons récemment reçu des demandes de support pour Capistrano 3. Pour
fournir un service de support de qualité, il faut connaitre le sujet, je me suis
donc lancé dans la quête de migrer scripts de déploiement de Capistrano 2 à
Capistrano 3. Comme toujours, cela a pris un peu plus de temps que prévu mais au
final le code est plus propre.</p>

<p>Je dois dire que j'ai eu un flashback remontant à deux ans, lorsque je mettais
en place Capistrano pour la première fois : la documentation est incomplète
et il faut jongler entre le
<a href="https://github.com/capistrano/capistrano">{l-en readme}</a>,
le <a href="https://github.com/capistrano/capistrano/wiki">wiki</a> et
<a href="http://www.capistranorb.com/">la page d'accueil officielle</a>. Mais c'est un
projet open-source et les participations pour améliorer cela sont les
bienvenues.</p>

<p>Je vais tenter de vous faciliter la migration en vous montrant notre nouvelle
configuration en parallèle de l'ancienne, étape par étape.</p>

<!-- more -->


<h2>Mettre en place la nouvelle configuration</h2>

<h3>Gemfile</h3>

<p>La première étape est d'installer de nouvelles gems. Capistrano 2 ne supportait
pas les configurations {l-en multistage}, il fallait pour cela
utiliser la gem <code>capistrano-ext</code>. Capistrano 3 supporte le
{l-en multistage} en standard. Il est indépendant de tout {l-en framework},
vous devez donc utiliser <code>capistrano-rails</code> si vous comptez déployer une
application {l-en Rails}. Suivez l'exemple ci-dessous pour mettre votre
{l-en Gemfile} à jour, lancez ensuite <code>bundle install</code> et vous êtes prêt pour la
migration.</p>

<p>Capistrano 2 :</p>

<pre><code class="ruby">group :development do
  gem "capistrano"
  gem "capistrano-ext"
end
</code></pre>

<p>Capistrano 3 :</p>

<pre><code class="ruby">group :development do
  gem "capistrano-rails"
end
</code></pre>

<h3>Ajouter Capistrano 3 à votre projet</h3>

<p>Comme le conseille
<a href="http://www.capistranorb.com/documentation/upgrading/">le guide officiel de mise à jour</a>,
il est préférable de copier les anciens fichiers Capistrano dans un endroit sûr,
au cas où, et d'ajouter les nouveaux fichiers générés à la main. Voici une
astuce pour le faire :</p>

<pre><code class="ruby">mkdir old_cap
mv Capfile old_cap
mv config/deploy.rb old_cap
mv config/deploy/ old_cap
</code></pre>

<p>Une fois cela fait, vous êtes prêt à mettre le nouveau Capistrano en place pour
votre projet :</p>

<pre><code>bundle exec cap install
</code></pre>

<h2>Capfile</h2>

<p>Parmi les fichiers fraichement générés, vous devriez trouver le nouveau
{l-en Capfile}. Ci-dessous, l'ancienne version de notre {l-en Capfile} suivie
de la nouvelle :</p>

<p>Capistrano 2 :</p>

<pre><code class="ruby">load "deploy"
load "deploy/assets"
Dir["vendor/gems/*/recipes/*.rb","vendor/plugins/*/recipes/*.rb"].each { |plugin| load(plugin) }
load "config/deploy"
</code></pre>

<p>Capistrano 3 :</p>

<pre><code class="ruby">require "capistrano/setup"
require "capistrano/deploy"

require "capistrano/bundler"
require "capistrano/rails/assets"
require "capistrano/rails/migrations"
require "whenever/capistrano"

Dir.glob("lib/capistrano/tasks/*.cap").each { |r| import r }
</code></pre>

<p>Votre nouveau {l-en Capfile} va contenir deux lignes commentées à propos du
support pour <code>rvm</code> et <code>rbenv</code>. Nous n'utilisons ni l'un ni l'autre pour gérer
Ruby sur nos serveurs je ne peux pas donc vous en dire long sur le sujet.</p>

<pre><code class="ruby">require "capistrano/rvm"
require "capistrano/rbenv"
</code></pre>

<h2>Configuration multistage</h2>

<p>Comme vous pouvez le voir ci-dessous, la configurations des {l-en stages} ne
change pas vraiment. Il y a cependant une chose à laquelle vous devez prêter
particulièrement attention. La façon de signifier à Capistrano une révision à
déployer a changé. Si vous faites du déploiement continu avec Capistrano, vous
avez probablement déjà vu la ligne suivante :</p>

<pre><code>bundle exec cap -S revision=$REVISION production deploy
</code></pre>

<p><code>REVISION</code> est une variable d'environnement que Semaphore exporte durant le
déploiement et Capistrano 2 l'utilisait comme paramètre. Avec Capistrano 3, cela
n'est plus possible et vous devez donner à la variable <code>branch</code> la révision ou
la branche que vous souhaitez déployer. Il était déjà possible de spécifier une
branche en configuration :</p>

<pre><code class="ruby">set :branch, ENV["BRANCH_NAME"] || "master"
</code></pre>

<p>Il nous suffit donc d'ajouter <code>ENV["REVISION"]</code> à la liste.</p>

<pre><code class="ruby">set :branch, ENV["REVISION"] || ENV["BRANCH_NAME"] || "master"
</code></pre>

<p>Cela fait partie des choses non documentées et il faut fouiller les sources ou
poser la question pour le savoir. L'un dans l'autre, le changement est assez
simple.</p>

<p>Le fichier suivant est notre <code>config/deploy/production.rb</code>.</p>

<p>Capistrano 2 :</p>

<pre><code class="ruby">server "server1.example.com", :app, :web, :db, :primary =&gt; true, :jobs =&gt; true
server "server2.example.com", :app, :web, :jobs =&gt; true

set :branch, ENV["BRANCH_NAME"] || "master"
</code></pre>

<p>Capistrano 3 :</p>

<pre><code class="ruby">set :stage, :production

server "server1.example.com", user: "deploy_user", roles: %w{web app db}
server "server2.example.com", user: "deploy_user", roles: %w{web app}

set :branch, ENV["REVISION"] || ENV["BRANCH_NAME"] || "master"
</code></pre>

<h2>Configuration principale - <code>config/deploy.rb</code></h2>

<p>C'est ici que les plus gros changements auront lieu. Voici ce à quoi il faut
faire attention :</p>

<ol>
<li>Vous n'avez plus besoin d'appeler <code>capistrano/ext/multistage</code> ou
<code>bundler/capistrano</code>. Le {l-en multistage} est supporté en standard et le
support de Bundler est fait dans le fichier Capfile.</li>
<li>Il n'est pas nécessaire de lister les {l-en stages} disponible ou celui par
défaut.</li>
<li>La variable pour régler l'url de dépôt source a changé de <code>repository</code> à
<code>repo_url</code>.</li>
<li><code>deploy_via :remote_cache</code> n'est plus nécessaire. La façon dont Capistrano
gère les dépôts a beaucoup changé, il maintient maintenant un mirroir du
dépôt sur votre serveur.</li>
<li>L'option PTY est activée par défaut.</li>
<li><code>ssh_options</code> a un peu changé je crois mais les réglages de base sont à peu
près les mêmes.</li>
<li>Capistrano prend maintenant en charge les liens symboliques dont vous avez
besoin. Il vous suffit de lui dire de parcourir <code>linked_files</code> and
<code>linked_dirs</code>.</li>
<li>Si vous n'utilisez ni <code>rvm</code> ni <code>rbenv</code>, vous devez surcharger les commandes
<code>rake</code> et <code>rails</code> (voyez le fichier deploy.rb de Capistrano 3).</li>
</ol>


<p>L'écriture de {l-en tasks} a également changé et il est nécessaire de fouiller
la documentation pour écrire ce que vous voulez. La bibliothèque utilisée en
dessous est <a href="https://github.com/capistrano/sshkit">SSHKit</a> qui semble bien
sympathique.</p>

<p><strong>Astuce :</strong> avec Capistrano 2 vous pouviez écrire <code>var_name</code> et obtenir sa
valeur. Avec la nouvelle version, vous devez toujours utiliser
<code>fetch(:var_name)</code>. Il m'a fallut un certain temps pour le comprendre alors que
je reprenais une {l-en task} que l'on utilise pour gérer nos {l-en workers}.</p>

<p>Capistrano 2 :</p>

<pre><code class="ruby">require "capistrano/ext/multistage" #1
require "bundler/capistrano"

set :application, "webapp"
set :stages, %w(production staging)
set :default_stage, "staging" #2

set :scm, :git
set :repository,  "git@github.com:example/webapp.git" #3
set :deploy_to, "/home/deploy_user/webapp"
set :deploy_via, :remote_cache #4

default_run_options[:pty] = true #5
set :user, "deploy_user"
set :use_sudo, false

ssh_options[:forward_agent] = true #6
ssh_options[:port] = 3456

set :keep_releases, 20

namespace :deploy do

  desc "Restart application"
  task :restart, :roles =&gt; :app, :except =&gt; { :no_release =&gt; true } do
    run "#{try_sudo} touch #{File.join(current_path,'tmp','restart.txt')}"
  end

  desc "Prepare our symlinks" #7
  task :post_symlink, :roles =&gt; :app, :except =&gt; { :no_release =&gt; true } do
    ["config/database.yml", "config/config.yml"].each do |path|
      run "ln -fs #{shared_path}/#{path} #{release_path}/#{path}"
    end
  end

end

after  "deploy",                   "deploy:post_symlink"
after  "deploy:restart",           "deploy:cleanup"
before "deploy:assets:precompile", "deploy:post_symlink"
</code></pre>

<p>Capistrano 3 :</p>

<pre><code class="ruby">set :application, "webapp"

set :scm, :git
set :repo_url,  "git@github.com:example/webapp.git"
set :deploy_to, "/home/deploy_user/webapp"

set :ssh_options, {
  forward_agent: true,
  port: 3456
}

set :log_level, :info

set :linked_files, %w{config/database.yml config/config.yml}
set :linked_dirs, %w{bin log tmp vendor/bundle public/system}

SSHKit.config.command_map[:rake]  = "bundle exec rake" #8
SSHKit.config.command_map[:rails] = "bundle exec rails"

set :keep_releases, 20

namespace :deploy do

  desc "Restart application"
  task :restart do
    on roles(:app), in: :sequence, wait: 5 do
      execute :touch, release_path.join("tmp/restart.txt")
    end
  end

  after :finishing, "deploy:cleanup"

end
</code></pre>

<h2>Conclusion</h2>

<p>Le code que vous obtenez au final et plus propre et Capistrano 3/SSHKit semble
un mélange puissant. Quoi qu'il en soit, certaines bibliothèques comme
<code>whenever</code> et <code>bugsnag</code> ne supportent pas encore Capistrano 3, vous devrez donc
écrire leurs règles vous-même.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir pour les rubyists (partie 2)]]></title>
    <link href="http://vfsvp.fr/article/elixir-pour-les-rubyists-2"/>
    <updated>2013-10-29T21:00:00+01:00</updated>
    <id>http://vfsvp.fr/article/elixir-pour-les-rubyists-2</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.natescottwest.com/blog/2013/10/09/elixir-for-rubyists-part-2/">Elixir for Rubyists part 2 par Nate West</a></p>

<p>Voici une tentative de réponse aux questions de la <a href="/article/elixir-pour-les-rubyists-1">partie 1</a>.</p>

<h2>Immuable ??</h2>

<p>Les variables d'Elixir sont immuables. Elles ne sont pas à assignation unique.
Je vous entends déjà dire &ldquo;Mais Nate ! Si on réassigne une variable, n'est-ce
pas une mutation ?&rdquo;. Non !</p>

<h2>Elixir assure la transparence référentielle des variables</h2>

<p>Transparence référentielle est une façon académique de dire &ldquo;quand je fais
quelque chose qui modifie une valeur, je peux toujours revenir à la valeur
originale&rdquo;. Jessica Kerr (<a href="https://twitter.com/jessitron">@jessitron</a>) appelle
cela &ldquo;données en entrée, données en sortie&rdquo; (<em>data in, data out</em>). Sous forme
de code :</p>

<!-- more -->


<pre><code class="elixir">name = "Nate"
# =&gt; "Nate"
String.upcase(name)
# =&gt; "NATE"
name
# =&gt; "Nate"
</code></pre>

<p><code>String.upcase</code> est référentiellement transparent. Il retourne une nouvelle
valeur transformée mais ne modifie pas la valeur originale. On peut comparer
cela avec <code>String#upcase!</code> en Ruby.</p>

<pre><code class="ruby">name = "Nate"
# =&gt; "Nate"
name.upcase!
# =&gt; "NATE"
name
# =&gt; "NATE"
</code></pre>

<p><code>String#upcase!</code> <em>n'est pas</em> référentiellement transparent. Non seulement il
retourne une valeur transformée mais modifie également la valeur originale.</p>

<p>Avec Elixir, dans le contexte d'une fonction vous ne pourrez pas modifier la
valeur d'une variable.</p>

<pre><code class="elixir">name = "Nate"
# =&gt; "Nate"
capitalize = fn(string) -&gt; string = String.upcase(string) end
# =&gt; #Function&lt;6.80484245 in :erl_eval.expr/5&gt;
capitalize.(name)
# =&gt; "NATE"
name
# =&gt; "Nate"
</code></pre>

<h2>En quoi la transparence référentielle est importante ?</h2>

<p>Pour faire court, un code référentiellement transparent est simple à tester,
facile à comprendre et à rendre <em>threadsafe</em>. Si on a ceci en Ruby :</p>

<pre><code class="elixir">greeting = "Hello"
do_something_to_string(greeting)
print(greeting)
</code></pre>

<p>On s'attend à ce que <code>greeting</code> ait la valeur &ldquo;Hello&rdquo; lorsque l'on appelle
<code>print</code> mais <code>do_something_to_string</code> a pu modifier la valeur de <code>greeting</code>.
D'autant plus si <code>greeting</code> est transmis un peu partout dans l'application et
passe par toutes sortes de <code>do_somethings</code>. Au moment d'afficher <code>greeting</code>, il
pourrait tout aussi bien contenir &ldquo;Game over !&rdquo;.</p>

<p>Pour en savoir plus :</p>

<ul>
<li><a href="http://confreaks.com/videos/2382-rmw2013-functional-principles-for-oo-development">Jessica Kerr’s Functional Principles (en)</a></li>
<li><a href="http://rubyrogues.com/115-rr-functional-and-object-oriented-programming-with-jessica-kerr/">Ruby Rogues Podcast: Functional and OO Programming (en)</a></li>
<li>Si vous pensez à d'autres ressources, dites le moi, je les ajouterai.</li>
</ul>


<h2>Un piège&hellip;</h2>

<p>Il est possible d'assigner une nouvelle valeur à une variable en se basant sur
sa valeur actuelle. Notez bien qu'ici <code>=</code> n'est pas un opérateur d'assignation.
C'est un opérateur de test de correspondance. Lorsque l'on utilise sur une
variable, on peut choisir de tester la valeur de la variable ou nous pouvons
l'autoriser à prendre une nouvelle valeur.</p>

<pre><code class="elixir">1 = 2 # la valeur 1 ne correspond pas à la valeur 2
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3

:a = 2 # la valeur :a, un atôme (un peu comme un symbole en Ruby),
       # ne correspond pas à la valeur 2
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3

num = 2 # num est une variable. Nous pouvons lui assigner 2 pour établir
        # une correspondance.
# =&gt; 2

^num = 3 # la valeur de num (2) ne correspond pas à la valeur 3
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3

num = 3 # ici on ne cherche pas de correspondance, on peut donc assigner la
        # valeur 3 à num
# =&gt; 3
</code></pre>

<p>Tel que je le comprends, cela fait parti d'Elixir pour des questions pratique
et est particulièrement utile pour écrire des macros. Les puristes de la
programmation fonctionnelle vont détester ça. Si c'est votre cas, vous pouvez
lire <a href="https://groups.google.com/forum/#!searchin/elixir-lang-core/single$20assignment/elixir-lang-core/FrK7MQGuqWc/2aimbHDAAHMJ">cette discussion</a>
au sujet de la réassignation de variables dans Elixir et jeter un oeil au
commentaire de Joe Armstrong.</p>

<p>Encore une fois, cela ne change pas l'état de l'objet. Il n'y a pas d'objet dans
Elixir. <code>num</code> est un simple conteneur de données auquel vous pouvez donner une
nouvelle valeur. Lorsque vous le faites, l'ancienne valeur va être retirée du
contexte d'exécution afin de laisser la place libre pour stocker une nouvelle
valeur.</p>

<h2>Essayez donc de le briser</h2>

<p>Vous aurez tout de même beaucoup de mal à écrire une fonction qui brise la
transparence référentielle. Si vous réassignez une variable dans une fonction,
vous ne changez sa valeur que pour le contexte de cette fonction.</p>

<pre><code class="elixir">defmodule Assignment do
  def change_me(string) do
    string = 2
  end
end

# lorsque vous compilez ce module, vous aurez un warning indiquant
# qu'une variable de type string n'est pas utilisée!

greeting = "Hi"
# =&gt; "Hi"
Assignment.change_me(greeting)
# =&gt; 2
greeting
# =&gt; "Hi"
</code></pre>

<h2>C'est tout pour aujourd'hui</h2>

<p>Voici la fin de la partie 2. À bientôt pour la partie 3.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir pour les rubyists (partie 1)]]></title>
    <link href="http://vfsvp.fr/article/elixir-pour-les-rubyists-1"/>
    <updated>2013-10-27T18:30:00+01:00</updated>
    <id>http://vfsvp.fr/article/elixir-pour-les-rubyists-1</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.natescottwest.com/blog/2013/09/26/elixir-for-rubyists/">Elixir for Rubyists part 1 par Nate West</a></p>

<p>Elixir est mon nouveau langage préféré. Cet article est le premier d'une série
de longueur indéterminée sur Elixir. En tant que rubyist, la syntaxe d'Elixir va
vous sembler familière. Je vais donc vous montrer beaucoup de code pour
vous expliquer comment il marche. Elixir est fonctionnel et amusant
(FUNctional).</p>

<p>Elixir est un langage fonctionnel qui tourne sur la VM Erlang mais ressemble
beaucoup à Ruby.</p>

<!-- more -->


<pre><code class="elixir">2 + 2
# =&gt; 4

IO.puts "Hello!"
# =&gt; Hello!
#    :ok

String.downcase("JE NE CRIE PAS")
# =&gt; "je ne crie pas"

defmodule Numbers do
  def add_to(num) do
    if is_number(num) do
      num + 2
    else
      raise(ArgumenError, message: "L'argument doit etre un nombre")
    end
  end
end

Numbers.add_to(4)
# =&gt; 6
Numbers.add_to("Nate")
# =&gt; ** (ArgumenError) L'argument doit etre un nombre
</code></pre>

<p>Elixir utilise la détection par motif (<em>pattern matching</em>) pour effectuer des
comparaisons et assigner des valeurs aux variables.</p>

<pre><code class="elixir">a = 2
# =&gt; 2

2 = a
# =&gt; 2

{ success, string } = { :ok, "Hey Joe, tu sais quoi ?" }
# =&gt; {:ok, "Hey Joe, tu sais quoi ?"}
success
# =&gt; :ok
string
# =&gt; "Hey Joe, tu sais quoi ?"
</code></pre>

<p>Elixir est fonctionnel, les variables sont donc immuables. Cependant,
contrairement à Erlang, ces dernières ne sont pas limitées à une seule
assignation. Si vous voulez détecter le motif de la valeur d'une variable, vous
devez utiliser un circonflexe <code>^</code>. Sans le circonflexe vous pouvez assigner une
nouvelle valeur à la variable.</p>

<pre><code class="elixir">a = 2
# =&gt; 2
^a = 3
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3
a = 3
# =&gt; 3
</code></pre>

<p>Comme tout langage fonctionnel, Elixir traite les fonctions comme des citoyens
de premier ordre. Vous pouvez assigner une fonction à une variable pour une
évaluation différée. Notez l'interpolation de chaîne dans l'exemple suivant,
une autre ressemblance à Ruby.</p>

<pre><code class="elixir">greeter = fn (name) -&gt; IO.puts "Hello #{name}" end
# =&gt; #Function&lt;6.80484245 in :erl_eval.expr/5&gt;
greeter.("Nate")
# =&gt; Hello Nate
#    :ok
</code></pre>

<p>Vous pouvez écrire des fonctions qui retournent des fonctions.</p>

<pre><code class="elixir">defmodule FunctionExamples do
  def build_greeter(kind) do
    case kind do
      :hello -&gt; fn (name) -&gt; "Coucou, #{name}!" end
      :goodbye -&gt; fn (name) -&gt; "A plus, #{name}!" end
      _ -&gt; fn (name) -&gt; "Je ne sais pas quoi te dire, #{name}." end
    end
  end
end

say_hello = FunctionExamples.build_greeter(:hello)
# =&gt; #Function&lt;0.63189797 in FunctionExamples.build_greeter/1&gt;
say_hello.("Nate")
# =&gt; Coucou, Nate!
#    :ok

wat = FunctionExamples.build_greeter(:something_else)
# =&gt; #Function&lt;2.63189797 in FunctionExamples.build_greeter/1&gt;
wat.("Nate")
# =&gt; "Je ne sais pas quoi te dire, Nate."
#    :ok
</code></pre>

<p>Comme dans d'autres langages fonctionnels, plutôt que de reposer sur des
boucles, Elixir utilise énormément la récursivité. Cela dit, le module <code>Enum</code>
fournit quelques fonctions bien connues des rubyists, comme <code>each</code> par exemple.</p>

<pre><code class="elixir">Enum.each(["Joe", "Matz", "Jose"], fn (name) -&gt; IO.puts(name) end)
# =&gt; Joe
# =&gt; Matz
# =&gt; Jose
# =&gt; :ok

defmodule RecursionExamples do
  def recurse([]) do
    :ok
  end
  def recurse([head|tail]) do
    IO.puts head
    recurse(tail)
  end
end

RecursionExamples.recurse(["Joe", "Matz", "Jose"])
# =&gt; Joe
# =&gt; Matz
# =&gt; Jose
# =&gt; :ok
</code></pre>

<p>C'est tout pour cette première partie. À bientôt pour <a href="/article/elixir-pour-les-rubyists-2">la deuxième</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[6 façons de réduire la souffrance due aux tests fonctionnels avec Rails]]></title>
    <link href="http://vfsvp.fr/article/6-facons-de-reduire-la-souffrance-des-tests-fonctionnels-avec-Rails"/>
    <updated>2013-10-12T13:00:00+02:00</updated>
    <id>http://vfsvp.fr/article/6-facons-de-reduire-la-souffrance-des-tests-fonctionnels-avec-Rails</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://gaslight.co/blog/6-ways-to-remove-pain-from-feature-testing-in-ruby-on-rails">6 Ways to Remove Pain From Feature Testing in Ruby on Rails de Mitch Lloyd</a></p>

<p>L'écriture des tests fonctionnels a été une des parts les plus douloureuses de
mon travail avec Ruby on Rails. Mais aujourd'hui c'est quelque chose que
j'apprécie et voici pourquoi :</p>

<h2>1. Je n'utilise pas Cucumber</h2>

<p><strong>Attention:</strong> Le point de vue exprimé dans le paragraphe suivant ne reflète pas
forcement celui de l'équipe ou des partenaires de Gaslight Software, LLC.</p>

<p>Si vous avez installé Cucumber, supprimez-le. Les tests sont déjà assez
difficiles sans que l'on ait besoin de transformer le langage naturel en code
Ruby.</p>

<!-- more -->


<p>J'utilise :</p>

<ul>
<li>Rspec &ndash; DSL spécialisé dans les tests</li>
<li>FactoryGirl &ndash; Constructeur de modèles</li>
<li>Capybara &ndash; DOM Dominator</li>
<li>Database Cleaner - Nettoyeur de bases de données</li>
<li>Spring - Accélérateur de démarrage</li>
</ul>


<p>Et j'en suis très content. Écrivons une spec.</p>

<pre><code class="ruby">feature 'Navigating through workpapers' do
  let(:user) { create(:user) }
  let(:audit) { create(:audit, users: [user]) }

  scenario "User sees workpapers within an audit" do
    workpaper = create(:workpaper, audit: audit)

    visit '/'
    fill_in 'email', with: user.email
    fill_in 'password', with: 'password'
    click_on 'Log In'

    find('#audit-selector').select audit.name
    expect(page).to have_css?('.workpaper', text: workpaper.name)
  end
end
</code></pre>

<p>Tout cela est plutôt pas mal mais une <em>feature</em> un peu plus complexe deviendrait
vite illisible. La logique de connexion va immanquablement être dupliquée entre
plusieurs tests. Même cette <em>feature</em> n'est pas aussi lisible que je le
souhaiterais.</p>

<h2>2. Utilisez des <em>Page Objects</em></h2>

<p>Les sélecteurs Capybara ont une forte probabilité de casser au fur et à mesure
que le développement avance. Le responsable du contenu décide que le bouton du
formulaire de connexion va maintenant indiquer &ldquo;Connectez-vous à un monde où
tout est possible&rdquo;, vous devez maintenant corriger tous vos tests.</p>

<p>Les <em>page objects</em> sont des interfaces spécifiques à votre DOM. Lorsque le HTML
change, vous saurez exactement où corriger cela dans vos tests.</p>

<p>Voici un <em>page objet</em> &ldquo;page de connexion" :</p>

<pre><code class="ruby">class LoginPage
  include Capybara::DSL

  def visit_page
    visit '/'
    self
  end

  def login(user)
    fill_in 'email', with: user.email
    fill_in 'password', with: 'password'
    click_on 'Log In'
  end
end
</code></pre>

<p>Voici un autre <em>page object</em> &ldquo;index des documents" :</p>

<pre><code class="ruby">class WorkpaperIndexPage
  include Capybara::DSL

  def select_audit(audit)
    find('#audit-selector').select audit.name
  end

  def has_workpaper?(workpaper)
    has_css?('.workpaper', text: workpaper.name)
  end
end
</code></pre>

<p>Et voici maintenant un test utilisant ces <em>page objects</em> :</p>

<pre><code class="ruby">feature 'Navigating through workpapers' do
  let(:user) { create(:user) }
  let(:audit) { create(:audit, users: [user]) }
  let(:login_page) { LoginPage.new }
  let(:workpaper_page) { WorkpaperIndexPage.new }

  scenario "User sees workpapers within an audit" do
    workpaper = create(:workpaper, audit: audit)

    login_page.visit_page.login(user)
    workpaper_page.select(audit)
    expect(workpaper_page).to have_workpaper(workpaper)
  end
end
</code></pre>

<p>Considérons maintenant que quelqu'un modifie sans arrêt ce bouton de connexion.
Vous avez simplement à modifier <code>LoginPage</code> et utiliser un ID ou une entrée I18n
(ce qui aurait été une bonne idée dés le départ). Vous n'avez à vous inquiéter
d'aucun autre test, tout ce qui concerne cette page est contenu dans ce <em>page
object</em>.</p>

<p>Ces objets sont assez simples mais peuvent tout à fait grossir pour fournir des
fonctionnalités supplémentaires comme la vérification d'erreurs au fur et à
mesure que l'utilisateur au travers des pages (ou sections) du site. Le retour
sur investissement des <em>page objects</em> est si rapide que j'utilise toujours ce
type d'objet dans mes tests fonctionnels. De la même façon que je n'écris jamais
de SQL dans mes vues Rails, je n'accède pas au DOM depuis un test fonctionnel
sans <em>page object</em>.</p>

<h2>3. Créer des messages d'erreur utiles</h2>

<p>Un test fonctionnel qui échoue peut être difficile à diagnostiquer. Mettons que
vous utilisez un <em>page object</em> comme ceci :</p>

<pre><code class="ruby">expect(workpaper_page).to have_one_workpaper(workpaper)
</code></pre>

<pre><code>Failure/Error: expect(workpaper_page).to have_one_workpaper(workpaper)
  expected #has_one_workpaper?(workpaper) to return true, got false
</code></pre>

<p>L'erreur est lisible mais il serait plus facile de savoir si elle est provoquée
par l'absence du document ou si la présence d'autres documents.</p>

<p>En général, je lève une exception lorsque j'appelle ce genre de prédicat sur
un <em>page object</em>.</p>

<pre><code>Failure/Error: expect(workpaper_page).to have_one_workpaper(workpaper)
  PageExpectationNotMetError:
    expected one workpaper called "My Sweet Workpaper", but the following
    workpapers were on the page:
      * "Bogus Workpaper"
      * "My Sweet Workpaper"
</code></pre>

<p>J'utilise cette technique avec modération et je cherche toujours une approche
plus élégante. Cela me donne tout de même des messages d'erreur plus précis et
m'épargne quelques aller-retours avec le navigateur. Faites moi signe si vous
utilisez une autre technique de retour d'erreur dans vos tests.</p>

<h2>4. Embrassez les tests asynchrones</h2>

<p>Une grande part de la frustration relative aux tests automatisés dans un
navigateur est due aux assertions qui doivent attendre. Ajouter un <code>sleep</code> à vos
tests est passable si vous pensez que l'un de vos tests a un souci de timing
mais un <code>sleep</code> ne devrait jamais se trouver dans votre code de test final.</p>

<p>Les tests clignotants (ceux qui échouent de façon intermittente) tuent la
confiance que vous avez envers votre suite de tests. Ils devraient être corrigés
ou supprimés.</p>

<p>En général, je conseille surtout de bien apprendre l'API de Capybara. Voici
quelques pointeurs :</p>

<ul>
<li><code>#all</code> n'attend pas, ce n'est dont probablement pas le <em>matcher</em> que vous
cherchez ;</li>
<li>La méthode <code>#has_css?</code> peut prendre un compteur en paramètre de façon à
indiquer combien d'éléments vous voulez attendre ;</li>
<li>Écrire un test comme <code>expect(page).to_not have_css('.post')</code> est, en général,
une mauvaise idée. Ce matcher attend l'apparition d'éléments <code>.post</code> pour
passer ce qui peut engendrer un certain ralentissement. Dans ce genre de cas,
il est préférable d'utiliser <code>expect(page).to have_no_css('.post')</code> qui
passera immédiatement si les éléments sont absents de la page ou attendra
leur disparition s'ils sont présents. Dans ce dernier cas, il vaut mieux
s'assurer de leur présence au préalable.</li>
</ul>


<p>Il peut arriver que vous souhaitiez attendre que quelque chose se produise en
dehors de Capybara. Pour cela, <a href="https://gist.github.com/mattwynne/1228927">ce helper</a>
<code>eventually</code> est très pratique :</p>

<p>Le code suivant attend que le document soit <em>awesome</em> et échoue si ce n'est pas le cas après deux secondes.</p>

<pre><code class="ruby">eventually { expect(workpaper).to be_awesome }
</code></pre>

<p>Quand pourriez-vous avoir besoin de ce type d'assertion en dehors de Capybara ?
Lisez la suite…</p>

<h2>5. Prenez la construction de données au sérieux</h2>

<p>Je me souviens avoir entendu un mantra pour les tests fonctionnels qui disait
&ldquo;Tout faire du point de vue de l'utilisateur&rdquo;. Ce conseil visait à l'origine à
décourager les testeurs de manipuler les données directement dans les tests
fonctionnels. Je peux vous assurer que c'était un mauvais conseil. Il est juste
impensable d'inscrire un utilisateur et de passer au travers de vingt autres
étapes simplement pour le faire cliquer sur un bouton.</p>

<p>J'utilise beaucoup FactoryGirl pour mettre en place mes données de test. Cela
signifie que j'ai des factories permettant de générer des objets complexes.
Voici, par exemple, comment faire un document avec un workflow ayant des étapes
assignées à certains utilisateurs appelés <code>preparers</code> et <code>reviewers</code>.</p>

<pre><code class="ruby">FactoryGirl.define do
  factory :workpaper do
    sequence(:name) {|n| "workpaper #{n}"}

    factory :assigned_workpaper do
      ignore do
        preparer { create(:user) }
        reviewer { create(:user) }
      end

      after(:create) do |workpaper, evaluator|
        create(:assigned_workflow, workpaper: workpaper, preparer: evaluator.preparer, reviewer: evaluator.reviewer)
      end
    end
  end

  factory :workflow do
    factory :assigned_workflow do
      ignore do
        preparer { create(:user) }
        reviewer false
      end

      after(:create) do |workflow, evaluator|
        create(:step, workflow: workflow, user: evaluator.preparer)

        if evaluator.reviewer
          create(:step, workflow: workflow, user: evaluator.reviewer)
        end
      end
    end
  end

  factory :step
end
</code></pre>

<p>Cela me permet de créer de façon déclarative des objets spécifiques à mes tests.</p>

<pre><code class="ruby">create(:assigned_workpaper, preparer: first_user, reviewer: second_user)
</code></pre>

<p>Je crée toujours des instances de mes modèles via FactoryGirl dans mes tests
fonctionnels. Je suis fan de FactoryGirl mais je pense qu'il est possible de
faire encore mieux en ce qui concerne la construction de données complexes comme
celles-ci. Quel que soit l'outil utilisé, la mise en place des données de test
doit toujours être lisible et facilement exploitable.</p>

<p>Il est non seulement acceptable de mettre en place des données avant de
commencer vos tests mais il est également acceptable de vérifier les effets de
bord qui ne sont pas nécessairement visibles par l'utilisateur. Dans le monde
des applications en client riche par exemple, voir quelque chose à l'écran ne
signifie pas forcement que tout a été sauvegardé en base de données.</p>

<p>Tout comme nous avons des helpers pour construire nos données, nous devrions
avoir des helpers pour les inspecter. Ce test va s'assurer que le <em>preparer</em>
d'un document a été sauvegardé en base de données :</p>

<pre><code class="ruby">eventually { preparer_for(workpaper).should be(preparer) }
</code></pre>

<h2>6. Créez moins de tests, affinez ceux existant</h2>

<p>Lorsque j'ai commencé à écrire des tests fonctionnels avec Rails, on m'a donné
le conseil suivant &ldquo;chaque test doit contenir une action et une assertion&rdquo;. J'ai
donc travaillé comme ceci :</p>

<ul>
<li>Écrire un scénario cucumber pour une fonctionnalité</li>
<li>Faire fonctionner le code</li>
<li>Écrire un scénario cucumber pour un autre aspect de la fonctionnalité</li>
<li>Faire fonctionner le code</li>
</ul>


<p>C'est une bonne méthodologie pour les tests unitaires mais c'est une mauvaise
idée en ce qui concerne les tests fonctionnels.</p>

<p>Prenons le test suivant :</p>

<pre><code class="ruby">scenario "assigning a reviewer to a workpaper" do
  user_visits_workpaper(user, workpaper)
  ui.begin_assigning_reviewer
  ui.assign_work_to(reviewer)
  eventually { expect(reviewer_for workpaper).to eq(other_tester) }
end
</code></pre>

<p>Lorsque l'on appelle <code>ui.begin_assigning_reviewer</code> une boite de dialogue
s'ouvre pour permettre à l'utilisateur de choisir qui qui sera le <code>reviewer</code>.
Cette fonctionnalité marche. Très bien.</p>

<p>Je veux maintenant m'assurer que le seuls les utilisateurs ayant le droit de
faire des relectures soient listés. Plutôt que de créer un nouveau test, je vais
affiner celui que je viens d'écrire :</p>

<pre><code class="ruby">scenario "assigning a reviewer to a workpaper" do
  user_visits_workpaper(user, workpaper)
  ui.begin_assigning_reviewer
  expect(ui).to have_excluded_user(non_reviewer)
  ui.assign_work_to(reviewer)
  eventually { expect(reviewer_for workpaper).to eq(other_tester) }
end
</code></pre>

<p>Je n'utiliserais bien sûr pas cette technique pour les tests unitaires mais elle
est efficace pour les tests fonctionnels dont le but est de guider votre
progression et détecter les régressions.</p>

<h2>Mais qui teste vos tests ?</h2>

<p>Lorsque vos tests commencent à contenir beaucoup de logique, quelqu'un va finir
par vous dire &ldquo;Mais qui teste vos tests ?&rdquo; pour vous signifier que vos tests
sont trop compliqués, trop complexes. Votre code de production teste vos tests.
Ce n'est pas pour autant une excuse pour écrire de mauvais tests ou des tests
illisibles.</p>

<p>Les outils et techniques cités ci-dessus vont changer au fur et à mesure que le
temps passe mais j'ai augmenté ma sensibilité aux mauvais tests fonctionnels
pour toujours. Refactorez de façon agressive, concevez intelligemment et aimez
vos tests fonctionnels.</p>
]]></content>
  </entry>
  
</feed>
