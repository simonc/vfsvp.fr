<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: rubymotion | VF svp]]></title>
  <link href="http://vfsvp.fr/tags/rubymotion/atom.xml" rel="self"/>
  <link href="http://vfsvp.fr/"/>
  <updated>2014-07-16T20:22:24+02:00</updated>
  <id>http://vfsvp.fr/</id>
  <author>
    <name><![CDATA[Simon Courtois (@simonc)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Une gem Ruby universelle en 20 lignes de code]]></title>
    <link href="http://vfsvp.fr/article/gem-universelle-en-20-lignes"/>
    <updated>2014-06-27T12:00:00+02:00</updated>
    <id>http://vfsvp.fr/article/gem-universelle-en-20-lignes</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://blog.crossplatformruby.com/universal-ruby-gems-in-20-lines-of-code">Universal Ruby Gems in 20 Lines of Code de Michal Taszycki</a></p>

<p>Les gems Ruby sont les blocs essentiels à la création d'applications Ruby Cross-Plateformes. Nous les utilisons pour encapsuler la logique de nos applications et extraire des fonctionnalités réutilisables sur différentes plateformes.</p>

<p>Je vais vous montrer comment préparer une gem Ruby pour qu'elle fonctionne avec <strong>Ruby</strong>, <strong>Opal.rb</strong> et <strong>RubyMotion</strong> sans aucune modification. De cette façon vous pourrez l'utiliser dans vos applications Rails/iOS/OSX/Android/Navigateur Client.</p>

<!-- more -->


<p>Nous avons tout d'abord besoin d'un gem d'exemple&hellip;</p>

<h2>La gem pig_latin</h2>

<p>La gem pig_latin est un simple utilitaire de traduction. Elle convertit n'importe quel mot anglais en son équivalent <a href="http://en.wikipedia.org/wiki/Pig_Latin">pig latin</a>.</p>

<p>Nous pouvons l'utiliser comme ceci :</p>

<pre><code class="ruby">PigLatin.translate("cross platform ruby")
#=&gt; "osscray atformplay ubyray"
</code></pre>

<p>La gem pig_latin est disponible sur <a href="https://github.com/crossplatformruby/pig_latin">github</a> vous pouvez donc en lire le code ou l'essayer.</p>

<p>C'est une petite gem toute bête avec laquelle on peut s'amuser. Elle a cependant un aspect qui la rend particulièrement intéressante.</p>

<p>Voyons ce qu'il se passe lorsque nous ajoutons la ligne suivante au Gemfile d'une application Rails ou RubyMotion.</p>

<pre><code class="ruby">gem 'pig_latin', git: 'git@github.com:crossplatformruby/pig_latin.git'
</code></pre>

<p>Et bien&hellip;</p>

<h2>Cela fonctionne partout !</h2>

<p>Que vous utilisiez Rails, RubyMotion ou même une application en ligne de commande, ça fonctionne tout seul. Si vous utilisez Opal.rb dans votre application, vous pouvez appeler <code>require</code> dessus et l'utiliser dans votre navigateur.</p>

<p>Essayez-la.</p>

<h3>Rails</h3>

<pre><code class="ruby">class TranslationsController &lt; ApplicationController
  def show
    @phrase = params[:phrase]
    @translation = PigLatin.translate(@phrase)
  end
end
</code></pre>

<p><img src="/images/universal_gems/rails.png" alt="Pig Latin avec Rails" /></p>

<h3>Opal.rb</h3>

<pre><code class="ruby">require "opal"
require "opal_ujs"
require "pig_latin"

puts PigLatin.translate("cross platform ruby")
</code></pre>

<p><img src="/images/universal_gems/opal.png" alt="Pig Latin dans un navigateur" /></p>

<h3>iOS</h3>

<pre><code class="ruby">class AppDelegate
  def application(application, didFinishLaunchingWithOptions:launchOptions)
    alert = UIAlertView.new
    alert.message = PigLatin.translate("cross platform ruby")
    alert.show
  end
end
</code></pre>

<p><img src="/images/universal_gems/ios.png" alt="Pig Latin sur iOS" /></p>

<h3>OSX</h3>

<pre><code class="ruby">class AppDelegate
  def applicationDidFinishLaunching(notification)
    buildMenu
    buildWindow

    alert = NSAlert.new
    alert.messageText = PigLatin.translate("cross platform ruby")
    alert.runModal
  end

  def buildWindow
    # (...) details omis pour plus de clareté
  end
end
</code></pre>

<p><img src="/images/universal_gems/osx.png" alt="Pig Latin sur OS X" /></p>

<h3>Android (bientôt)</h3>

<p>Dans les mois qui viennent, RubyMotion permettra la création d'applications Ruby pour Android. Je mettrais à jour cet article quand ce sera possible. Il semble cependant qu'aucun réglage additionnel ne sera nécessaire.</p>

<h2>Comment cela fonctionne-t-il ?</h2>

<p>Lorsque l'on parle d'écrire une gem, la principale différence entre les plateformes est la façon dont les fichiers sont appelés.</p>

<p>RubyMotion et Opal.rb ne permettent pas l'usage de <code>require</code> au runtime. Nous devons donc nous assurer que tous les fichiers de notre gem sont appelés en amont.</p>

<p>En Ruby Cross-Plateforme, le fichier faisant office de point d'entrée devient le manifeste de la gem.</p>

<h3>1. Faire fonctionner la gem avec Ruby</h3>

<p>Si votre seule plateforme est MRI ou Rubinius, votre point d'entrée, <code>pig_latin.rb</code>, doit ressembler à ceci :</p>

<pre><code class="ruby">require "pig_latin/version"
require "pig_latin/word_translator"
require "pig_latin/phrase_translator"
require "pig_latin/class_methods"
</code></pre>

<p>Aucun code spécifique à la gem ne doit être présent dans ce fichier, uniquement une suite d'appels à <code>require</code>, c'est important pour plus tard.</p>

<h3>2. Supporter Opal.rb</h3>

<p>Il est facile de faire fonctionner notre manifeste sous Opal. Collez simplement le code ci-dessous n'importe où dans <code>pig_latin.rb</code>.</p>

<pre><code class="ruby">if defined?(Opal) &amp;&amp; defined?(File)
  Opal.append_path File.expand_path('.', File.dirname(__FILE__))
end
</code></pre>

<p>Il est plus difficile de comprendre pourquoi ça fonctionne.</p>

<p>Lorsque Opal compile les fichiers, il transforme les appels à <code>require</code> en directives <code>Sprockets</code>. Cela veut dire qu'au moment où l'on appelle <code>application.rb</code>, il comprend les <code>require</code> mais ne sait pas où trouver les fichiers.</p>

<p>C'est pour cette raison que nous devons ajouter le chemin du dossier contenant notre point d'entrée grâce à <code>Opal#append_path</code>.</p>

<p>Cela veut dire que notre manifeste est lancé deux fois :</p>

<ol>
<li>En Ruby, lorsque la gem est appelée pour informer Opal des chemins à charger ;</li>
<li>En Opal.rb pour traduire les <code>require</code> en directives <code>Sprockets</code>.</li>
</ol>


<h3>3. Compiler pour RubyMotion</h3>

<p>RubyMotion ne permet pas d'appeler <code>require</code> au runtime. Nous devons donc lui fournir la liste des fichiers à compiler. Il serait cependant plus intéressant de conserver notre succession de <code>require</code> et de nous en servir pour générer cette liste.</p>

<p>Puisque notre manifeste est lancé avec Ruby, nous pouvons le faire en utilisant la technique suivante.</p>

<p>Commençons par redéfinir la méthode <code>require</code> :</p>

<pre><code class="ruby">if defined?(Motion::Project::Config)
  def rubymotion_require(filename)
    @files_to_require ||= []
    @files_to_require &lt;&lt; filename
  end

  alias :old_require :require
  alias :require :rubymotion_require
end
</code></pre>

<p>Nous appelons ensuite <code>require</code> comme d'habitude.</p>

<p>Pour finir, nous construisons la liste des fichiers à compiler et remettons <code>require</code> en place une fois terminé.</p>

<pre><code class="ruby">if defined?(Motion::Project::Config)
  alias :require :old_require

  Motion::Project::App.setup do |app|
    paths_to_require = @files_to_require.map do |file|
      File.join(File.dirname(__FILE__), file + ".rb")
    end

    app.files.unshift(*paths_to_require)
  end
end
</code></pre>

<h2>En résumé</h2>

<p>En utilisant quelques astuces et une organisation intelligente des fichiers, nous avons réussi à créer une gem qui fonctionne sur les serveurs, dans les applications lourdes, dans les navigateurs et sur mobiles. Cela permet de partager du code entre plusieurs applications.</p>

<p>Vous pouvez très facilement adapter ces techniques à vos propres gems. Cela prend littéralement 20 lignes de code pour les rendre universelles.</p>
]]></content>
  </entry>
  
</feed>
