<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: javascript | VF svp]]></title>
  <link href="http://vfsvp.fr/tags/javascript/atom.xml" rel="self"/>
  <link href="http://vfsvp.fr/"/>
  <updated>2014-06-23T20:05:58+02:00</updated>
  <id>http://vfsvp.fr/</id>
  <author>
    <name><![CDATA[Simon Courtois (@simonc)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Une introduction en profondeur à Ember.js]]></title>
    <link href="http://vfsvp.fr/article/une-introduction-en-profondeur-a-emberjs"/>
    <updated>2014-01-16T12:00:00+01:00</updated>
    <id>http://vfsvp.fr/article/une-introduction-en-profondeur-a-emberjs</id>
    <content type="html"><![CDATA[<p>Source:
[An In-Depth Introduction To Ember.js de Julien Knebel pour Smashing][ORIGINAL]</p>

<p>Maintenant que {l-en Ember.js 1.0} est sorti, il est temps d'y jeter un coup
d'oeil. Cet article s'adresse aux débutants qui souhaitent comprendre ce
{l-en framework}.</p>

<!-- more -->


<p>
Il est fréquent d'entendre les utilisateurs dire que la courbe d'apprentissage
est raide mais qu'une fois les difficultés surmontées, {l-en Ember.js} est
tout simplement phénoménal. Ça a été également le cas pour moi. Bien que les
[guides officiels][GUIDES] soient extrêment précis et parfaitement à jour
(vraiment !), cet article a pour but de rendre les choses encore plus aisées
pour les débutants.</p>

<p>Tout d'abord, nous allons éclaircir les principaux concepts du
{l-en framework}. Nous verrons ensuite, étape par étape, comment construire
une application avec {l-en Ember.js} et {l-en Ember-Data}, la couche de
stockage de données d'{l-en Ember}. Nous verrons ensuite comment les <code>views</code> et
les <code>components</code> aident à gérer les interactions utilisateurs.</p>

<p><img src="/images/ember/emberjs-logo.png" alt="Une introduction en profondeur à Ember.js" /><br />
La fameuse mascotte d'{l-en Ember}, {l-en Tomster}.
(<a href="http://emberjs.com/">Crédits</a>)</p>

<p>La <strong>démo non stylisée</strong> ci-dessous, vous aidera à suivre chaque étape de ce
tutoriel. La <strong>démo stylisée</strong> est essentiellement la même mais avec bien plus
de CSS, d'animations et de réactivité sur petits écrans.</p>

<p>[Démo non stylisée][UNSTYLED_DEMO]
<a href="https://github.com/jkneb/ember-crud">Code source</a>
[Démo stylisée][STYLED_DEMO]</p>

<h2>Sommaire</h2>

<p>{{TOC}}</p>

<h2>Principaux concepts</h2>

<p>Le schéma ci-dessous montre comment les routes, les contrôleurs, les vues, les
{l-en templates} et les modèles interagissent les uns avec les autres.</p>

<p><img src="/images/ember/ember-sketch.png" alt="ember-sketch" /></p>

<p>Voici une description de chacun des concepts. Pour en apprendre plus,
référez-vous à la section correspondante dans les guides officiels :</p>

<ul>
<li>[Modèles][GUIDES_MODELS]</li>
<li><a href="http://emberjs.com/guides/routing">Le Routeur</a></li>
<li>[Contrôleurs][GUIDES_CONTROLLERS]</li>
<li><a href="http://emberjs.com/guides/views">Vues</a></li>
<li><a href="http://emberjs.com/guides/components/">Composants</a></li>
<li><a href="http://emberjs.com/guides/templates/handlebars-basics">Templates</a></li>
<li><a href="http://emberjs.com/guides/templates/writing-helpers">Helpers</a></li>
</ul>


<h3>Modèles</h3>

<p>Mettons que notre application gère une liste d'utilisateurs. Ces utilisateurs
et leurs informations seraient le modèle. Vous pouvez voir cela comme les
données stockées en base de données. Les modèles peuvent être récupérés et mis à
jour en implémentant des {l-en callbacks} AJAX dans vos routes ou vous pouvez
utiliser {l-en Ember-Data} (une couche d'abstraction de stockage de donnés)
pour simplifier la récupération, la mise à jour et la persistence des modèles
au travers d'une API REST.</p>

<h3>Le Routeur</h3>

<p>Il y a le <code>Router</code> et, ensuite, les routes. Le <code>Router</code> est juste un synopsis de
toutes vos routes. Les routes sont la version URL des objects de votre
application (par exemple, une route <code>posts</code> correspond à un {l-en listing}
d'utilisateurs). Le but des routes est d'appeler le modèle, via leur
{l-en hook} <code>model</code>, pour qu'il soit accessible dans les contrôleurs et
{l-en templates}. Les routes peuvent également servir à valuer les propriétés
d'un contrôleur, à exécuter des événements ou des actions, ou encore connecter
un {l-en template} à un contrôleur spécifique. De plus, le {l-en hook}
<code>model</code> peut retourner une {l-en promise} ce qui permet d'implémenter une
<code>LoadingRoute</code> qui attend que le modèle soit récupéré de façon asynchrone.</p>

<h3>Contrôleurs</h3>

<p>Un <code>controller</code> commence par récupérer le modèle d'une <code>route</code>. Il fait ensuite
le pont entre le modèle et la vue ou le {l-en template}. Mettons que vous ayez
besoin d'une fonction pour alterner entre le mode édition et le mode normal. Des
méthodes comme <code>goIntoEditMode()</code> et <code>closeEditMode()</code> seraient parfaites et
c'est exactement ce à quoi servent les contrôleurs.</p>

<p>{l-en Ember.js} génère automatiquement les contrôleurs si vous ne les
déclarez pas. Vous pouvez par exemple créer un {l-en template} <code>user</code> et
une <code>UserRoute</code> sans créer de <code>UserController</code> (parce que vous n'en avez pas
besoin), {l-en Ember.js} le créera pour vous en interne (en mémoire).
L'extension Chrome appelée [Ember Inspector][EMBER_INSPECTOR] peut vous aider à
trouver ces contrôleurs magiques.</p>

<h3>Vues</h3>

<p>Les vues représentent les différentes parties de votre application (les parties
visibles par l'utilisateur dans le navigateur). Une <code>View</code> est associée à un
<code>Controller</code>, un <code>template</code> {l-en Handlebars} et une <code>Route</code>. La différence
entre vue et {l-en template} est particulière. Vous utiliserez une vue lorsque
vous voudrez gérer des événements ou des interactions utilisateurs qui ne
peuvent pas être pris en charge par un simple {l-en template}. Elle ont un
{l-en hook} bien pratique appelé <code>didInsertElement</code> au travers duquel vous
pouvez appeler jQuery très facilement et sont également très utiles pour créer
des vues réutilisables comme une {l-en modal}, une {l-en popover}, un
{l-en date-picker} ou encore un champ auto-complété.</p>

<h3>Components</h3>

<p>Un <code>Component</code> est une <code>View</code> complètement isolée, qui n'a pas accès au context
dans lequel il est appelé. C'est un excellent moyen de créer un composant
réutilisable pour votre application. Ce [Button Twitter][TWITTER_BTN], ce
[select personnalisé][CUSTOM_SELECT] ou encore ces
<a href="http://jsbin.com/odosoy/132/edit?html,js,output">graphiques réutilisables</a>
sont de très bons exemples de composants. Ce sont en fait de si bonnes idées que
le W3C travaille actuellement avec l'équipe {l-en Ember} sur la
[spécification d'éléments personnalisés][WEB_COMPONENTS].</p>

<h3>Templates</h3>

<p>Pour faire simple, un {l-en template} est la partie HTML d'une vue. Il permet
d'afficher les données du modèle et se met automatiquement à jour lorsque ce
dernier change. {l-en Ember.js} utilise [Handlebars][HANDLEBARS], un mécanisme
léger de {l-en templating} également maintenu par l'équipe {l-en Ember}. Il
fournit les outils logiques habituels comme <code>if</code> et <code>else</code>, les boucles et les
<code>helpers</code> de formatage, ce genre de choses. Les {l-en templates} peuvent être
précompilés (si vous souhaitez les organiser en fichiers <code>.hbs</code> ou <code>.handlebars</code>
séparés) ou tout simplement écrits dans une balise
<code>&lt;script type="text/x-handlebars"&gt;&lt;/script&gt;</code> dans votre page HTML. Pour en
savoir plus sur le sujet, vous pouvez vous reporter à la section
<a href="#precompiler-ou-non-les-templates">Précompiler ou non les {l-en templates}</a>.</p>

<h3>Helpers</h3>

<p>Les {l-en helpers} {l-en Handlebars} sont des fonctions qui modifient les
données avant leur affichage (par exemple, pour donner un meilleur format que
<code>Mon Jul 29 2013 13:37:39 GMT+0200 (CEST)</code> à une date). Si votre date est écrite
sous la forme <code>{{date}}</code> dans votre {l-en template} et que vous avez un
{l-en helper} <code>formatDate</code> (qui converti une date en quelque chose de plus
élégant, comme &ldquo;Il y a un mois&rdquo; ou &ldquo;29 juillet 2013&rdquo;), vous pouvez vous en
servir en utilisant <code>{{formatDate date}}</code>.</p>

<h3>Composants ? Helpers ? Vues ? Au secours !</h3>

<p>Le forum {l-en Ember.js} a [une réponse][EMBER_FORUM], tout comme
[StackOverflow][STACKOVERFLOW], qui peuvent vous éviter les maux de crâne.</p>

<h2>Créons une application</h2>

<p>Dans cette section, nous allons créer une véritable application, une simple
interface de gestion d'utilisateurs (une application de
<a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a>). Voici ce
que nous allons faire :</p>

<ul>
<li>un tour de l'architecture que nous souhaitons mettre en place ;</li>
<li>voir les dépendances, la structure de fichiers, etc ;</li>
<li>mettre en place le modèle avec le <code>FixtureAdapter</code> d'{l-en Ember-Data} ;</li>
<li>voir comment les routes, contrôleurs, vues et {l-en templates} interagissent ;</li>
<li>et enfin, remplacer <code>FixtureAdapter</code> par <code>LSAdapter</code> pour stocker les données
dans le {l-en local storage} du navigateur.</li>
</ul>


<h3>Schéma de notre application</h3>

<p>Nous avons besoin d'une vue assez simple qui affiche un groupe d'utilisateurs
(voir 1 ci-dessous). Il nous faut également une vue pour voir les informations
d'un utilisateur spécifique (2). Nous devons être capables de modifier et
supprimer ces informations (3). Nous devons enfin être à même de créer un nouvel
utilisateur, pour ce faire nous réutiliserons le formulaire de modification.</p>

<p><img src="/images/ember/app-sketch.png" alt="app-sketch" /></p>

<p>{l-en Ember.js} utilise beaucoup les conventions de nommage. Si vous voulez
avoir la page <code>/foo</code> dans votre application, vous aurez ce qui suit :</p>

<ul>
<li>un {l-en template} <code>foo</code> ;</li>
<li>une route <code>FooRoute</code> ;</li>
<li>un contrôleur <code>FooController</code> ;</li>
<li>une vue <code>FooView</code>.</li>
</ul>


<p>Pour en savoir plus, référez-vous à la section
<a href="http://emberjs.com/guides/concepts/naming-conventions">Naming conventions</a>
dans les guides.</p>

<h3>Ce qu'il vous faut pour bien commencer</h3>

<p>Vous aurez besoin de :</p>

<ul>
<li>jQuery ;</li>
<li>{l-en Ember.js}, bien sûr ;</li>
<li>{l-en Handlebars} le moteur de {l-en template} d'{l-en Ember} ;</li>
<li>{l-en Ember-Data}, la couche d'abstraction de stockage d'{l-en Ember}.</li>
</ul>


<pre><code class="html">/* /index.html
*/
 …
 &lt;script src="http://vfsvp.fr//code.jquery.com/jquery-2.0.3.min.js"&gt;&lt;/script&gt;
 &lt;script src="http://vfsvp.fr//builds.emberjs.com/handlebars-1.0.0.js"&gt;&lt;/script&gt;
 &lt;script src="http://vfsvp.fr//builds.emberjs.com/tags/v1.1.2/ember.js"&gt;&lt;/script&gt;
 &lt;script src="http://vfsvp.fr//builds.emberjs.com/tags/v1.0.0-beta.3/ember-data.js"&gt;&lt;/script&gt;
 &lt;script&gt;
   // votre code
 &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Le site d'{l-en Ember} a un section [Builds][EMBER_BUILDS] dans laquelle vous
pouvez trouver tous les liens vers {l-en Ember.js} et {l-en Ember-Data}. Pour
le moment, {l-en Handlebars} n'est pas présent sur la page, vous le trouverez
sur le [site officiel de Handlebars][HANDLEBARS].</p>

<p>Une fois les dépendances récupérées, nous pouvons commencer à créer notre
application. Nous allons tout d'abord créer un fichier nommé <code>app.js</code> dans
lequel nous allons initialiser {l-en Ember} :</p>

<pre><code class="javascript">/* /app.js
*/
window.App = Ember.Application.create();
</code></pre>

<p>Juste pour vérifier que tout fonctionne, vous devriez voir les {l-en logs} de
{l-en debug} dans la console du navigateur.</p>

<p><img src="/images/ember/console-log-1.png" alt="console-log-1" /></p>

<h3>Organisation de nos fichiers</h3>

<p>Il n'y a pas vraiment de convention en ce qui concerne l'organisation des
fichiers et dossiers.
L'<a href="https://github.com/stefanpenner/ember-app-kit">App Kit Ember</a> (un
environnement de démarrage d'application {l-en Ember} basé sur {l-en Grunt})
propose une sorte de standard puisqu'il est maintenu par l'équipe {l-en Ember}.
Pour faire encore plus simple, vous pourriez tout mettre dans le fichier
<code>app.js</code>. C'est à vous de voir.</p>

<p>Pour ce tutoriel, nous mettrons les contrôleurs dans un dossier <code>controllers</code>,
nos vues dans un dossier <code>views</code> et ainsi de suite.</p>

<pre><code>components/
controllers/
helpers/
models/
routes/
templates/
views/
app.js
router.js
store.js
</code></pre>

<h3>Précompiler ou non les {l-en templates} ?</h3>

<p>Il y a deux façons de déclarer les {l-en templates}. La plus simple est
d'ajouter une balise <code>script</code> spéciale dans votre fichier <code>index.html</code>.</p>

<p>``` html</p>

<script type="text/x-handlebars" id="templatename">
  <div>Je suis un template</div>
</script>


<pre><code>
Pour chaque {l-en template}, il vous faut une balise `script`. C'est simple et
rapide mais ça peut très vite devenir un gros désordre si vous avez beaucoup de
{l-en templates}.

L'alternative est de créer un fichier `.hbs` (ou `.handlebars`) pour chaque
{l-en template}. C'est ce qu'on appelle la "précompilation de {l-en templates}"
et une
[section entière](#quest-ce-que-la-precompilation-de-templates-handlebars) de
cet article y est dédiée.

Notre [démo non stylisée][UNSTYLED_DEMO] utilise
des balises `&lt;script type="text/x-handlebars"&gt;` et tous les {l-en templates} de
notre [démo améliorée][STYLED_DEMO] sont stockés dans des fichiers `.hbs` qui
sont précompilés par une tâche [Grunt][GRUNT]. Vous pouvez ainsi
comparer les deux techniques.

### Créer notre modèle avec le {l-en FixtureAdapter} de {l-en Ember-Data}

{l-en Ember-Data} est une bibliothèque qui permet de récupérer les données
stockées sur le serveur, de les retenir dans un `Store`, de les mettre à jour
dans le navigateur et enfin des les renvoyer au serveur pour sauvegarde. Le
`Store` peut être configuré avec différents {l-en adapters} (par exemple, le
`RESTAdapter` qui interagit avec une API JSON ou le `LSAdapter` qui stocke les
données dans le {l-en local storage} du navigateur).
Une [section entière](#quest-ce-quember-data) de cet article est dédiée à
{l-en Ember-Data}.

Nous allons utiliser `FixtureAdapter`. Nous commençons donc par l'instancier :
</code></pre>

<p>/<em> /store.js
</em>/
App.ApplicationAdapter = DS.FixtureAdapter;
```</p>

<p>Dans les versions précédentes d'{l-en Ember}, il fallait hériter de <code>DS.Store</code>.
Ce n'est plus nécessaire pour instancier les {l-en adapters}.</p>

<p><code>FixtureAdapter</code> est un très bon moyen de démarrer avec {l-en Ember.js} et
{l-en Ember-Data}. Il vous permet de travailler avec des données en
développement. Nous passerons au
[LocalStorage adapter][LSAdapterGihub]
(ou <code>LSAdapter</code>) en fin de parcours.</p>

<p>Commençons par définir notre modèle. Un utilisateur aura un nom <code>name</code>, une
adresse <code>email</code>, une courte <code>bio</code>, un avatar <code>avatarUrl</code> et une date de création
<code>creationDate</code>.</p>

<pre><code class="javascript">/* /models/user.js
*/
App.User = DS.Model.extend({
  name         : DS.attr(),
  email        : DS.attr(),
  bio          : DS.attr(),
  avatarUrl    : DS.attr(),
  creationDate : DS.attr()
});
</code></pre>

<p>Ajoutons ensuite quelques données d'exemple dans notre <code>Store</code>. Vous pouvez
ajouter autant d'utilisateurs que vous le souhaitez :</p>

<pre><code class="javascript">/* /models/user.js
*/
App.User.FIXTURES = [{
  id: 1,
  name: 'Sponge Bob',
  email: 'bob@sponge.com',
  bio: 'Lorem ispum dolor sit amet in voluptate fugiat nulla pariatur.',
  avatarUrl: 'http://jkneb.github.io/ember-crud/assets/images/avatars/sb.jpg',
  creationDate: 'Mon, 26 Aug 2013 20:23:43 GMT'
}, {
  id: 2,
  name: 'John David',
  email: 'john@david.com',
  bio: 'Lorem ispum dolor sit amet in voluptate fugiat nulla pariatur.',
  avatarUrl: 'http://jkneb.github.io/ember-crud/assets/images/avatars/jk.jpg',
  creationDate: 'Fri, 07 Aug 2013 10:10:10 GMT'
}
…
];
</code></pre>

<p>Pour en savoir plus sur les modèles, consultez
[la documentation][GUIDES_MODELS].</p>

<h3>Instancier le Router</h3>

<p>Définissons notre <code>Router</code> avec les routes dont nous avons besoin (basées sur le
<a href="#schema-de-notre-application">diagramme vu précédemment</a>).</p>

<pre><code class="javascript">/* /router.js
*/
App.Router.map(function(){
  this.resource('users', function(){
    this.resource('user', { path:'/:user_id' }, function(){
      this.route('edit');
    });
    this.route('create');
  });
});
</code></pre>

<p>Le <code>Router</code> va générer les routes suivantes :</p>

<table>
<thead>
<tr>
<th>URL                  </th>
<th> Route Name   </th>
<th> Controller            </th>
<th> Route            </th>
<th> Template</th>
</tr>
</thead>
<tbody>
<tr>
<td>N/A                  </td>
<td> N/A          </td>
<td> ApplicationController </td>
<td> ApplicationRoute </td>
<td> application</td>
</tr>
<tr>
<td>/                    </td>
<td> index        </td>
<td> IndexController       </td>
<td> IndexRoute       </td>
<td> index</td>
</tr>
<tr>
<td>N/A                  </td>
<td> users        </td>
<td> UsersController       </td>
<td> UsersRoute       </td>
<td> users</td>
</tr>
<tr>
<td>/users               </td>
<td> users.index  </td>
<td> UsersIndexController  </td>
<td> UsersIndexRoute  </td>
<td> users/index</td>
</tr>
<tr>
<td>N/A                  </td>
<td> user         </td>
<td> UserController        </td>
<td> UserRoute        </td>
<td> user</td>
</tr>
<tr>
<td>/users/:user_id      </td>
<td> user.index   </td>
<td> UserIndexController   </td>
<td> UserIndexRoute   </td>
<td> user/index</td>
</tr>
<tr>
<td>/users/:user_id/edit </td>
<td> user.edit    </td>
<td> UserEditController    </td>
<td> UserEditRoute    </td>
<td> user/edit</td>
</tr>
<tr>
<td>/users/create        </td>
<td> users.create </td>
<td> UsersCreateController </td>
<td> UsersCreateRoute </td>
<td> users/create</td>
</tr>
</tbody>
</table>


<p>La partie <code>:user_id</code> est appelée segment dynamique. L'{l-en ID} de l'utilisateur
sera injecté dans l'URL à cet emplacement. Cela aura donc la forme
<code>/users/3/edit</code>, <code>3</code> représentant l'utilisateur d'{l-en ID} 3.</p>

<p>Vous pouvez définir soit une <code>route</code>, soit une <code>resource</code>. Une <code>resource</code> est un
groupe de routes et permet d'imbriquer d'autres routes.</p>

<p>Une <code>resource</code> réinitialise également la convention de nommage de la ressource
précédente. Cela signifie qu'au lieu d'avoir <code>UsersUserEditRoute</code>, nous aurons
<code>UserEditRoute</code>. En d'autres termes, si vous avez une ressource imbriquée dans
une autre ressource, les noms de nos fichiers seraient :</p>

<ul>
<li><code>UserEditRoute</code> au lieu de <code>UsersUserEditRoute</code> ;</li>
<li><code>UserEditControler</code> au lieu de <code>UsersUserEditController</code> ;</li>
<li><code>UserEditView</code> au lieu de <code>UsersUserEditView</code> ;</li>
<li>pour les {l-en templates}, <code>user/edit</code> au lieu de <code>users/user/edit</code>.</li>
</ul>


<p>Vous pouvez en [apprendre plus sur les routes][ROUTES_GUIDES] dans les guides.</p>

<h3>Le {l-en template} de l'application</h3>

<p>Chaque application {l-en Ember.js} nécéssite un {l-en template} <code>Application</code>
contenant une balise <code>{{outlet}}</code> qui permet de contenir tous les autres
{l-en templates}.</p>

<p>``` html
/<em> /templates/application.hbs
</em>/</p>

<div class="main">
  <h1>Hello World</h1>
  {{outlet}}
</div>


<pre><code>
Si vous suivez ce tutorial sans précompiler vos {l-en templates}, voici ce à
quoi devrait ressembler votre `index.html` :
</code></pre>

<p>/<em> /index.html
</em>/
  …
  <script type="text/x-handlebars" id="application">
    <div class="main">
      <h1>Hello World</h1>
      {{outlet}}
    </div>
  </script></p>

<p>  <script src="dependencies.js"></script>
  <script src="your-app.js"></script>
</body>
</html>
```</p>

<h3>La route {l-en users}</h3>

<p>Cette route est liée à notre liste d'utilisateurs. Comme nous l'avons vu
<a href="#le-routeur">précédemment</a> dans les définitions, une route est chargée
d'appeler le modèle. Les routes ont un {l-en hook} <code>model</code> au travers duquel
nous pouvons effectuer une requête AJAX (pour récupérer les données lorsque
l'on n'utilise pas {l-en Ember-Data}) ou faire appel au <code>Store</code> (si l'on utilise
{l-en Ember-Data}). Si vous souhaitez savoir comment récupérer les données sans
{l-en Ember-Data}, vous pouvez consulter la <a href="#sans-utiliser-ember-data">section</a>
dans laquelle j'explique brièvement comment le faire.</p>

<p>Créons maintenant notre <code>UsersRoute</code> :</p>

<pre><code class="javascript">/* /routes/usersRoute.js
*/
App.UsersRoute = Ember.Route.extend({
  model: function(){
    return this.store.find('user');
  }
});
</code></pre>

<p>Vous pouvez en savoir plus sur
[comment utiliser le {l-en hook} <code>model</code> des routes][ROUTE_MODEL] dans les
guides.</p>

<p>Si vous visitez votre application à l'URL <code>http://localhost/#/users</code>, rien ne se
produit, nous avons d'abord besoin du {l-en template} <code>users</code>. Le voici :</p>

<p>``` html
/<em> /templates/users.hbs
</em>/</p>

<ul class="users-listing">
  {{#each user in controller}}
    <li>{{user.name}}</li>
  {{else}}
    <li>pas d'utilisateurs… :-(</li>
  {{/each}}
</ul>


<pre><code>
La boucle `each` parcourt la collection d'utilisateurs, `controller` vaut ici
`UsersController`. Notez que la boucle `{{#each}}` contient un `{{else}}` de
façon à ce que, lorsque le modèle est vide, `pas d'utilisateurs… :-(` soit
affiché.

Comme nous suivons la convention de nommage d'{l-en Ember}, nous pouvons nous
passer de déclarer `UsersController`. {l-en Ember} devine que l'on gère une
collection car nous avons utilisé la forme plurielle de "user".

### ObjectController vs. ArrayController

Un `ObjectController` est lié à un seul objet et un `ArrayController` est lié à
un groupe d'objets (comme une collection). Comme nous venons de le voir, nous
n'avons pas besoin de déclarer de `ArrayController`. Juste pour cet article,
nous allons cependant le déclarer pour lui attribuer quelques propriétés :
</code></pre>

<p>/<em> /controllers/usersController.js
</em>/
App.UsersController = Ember.ArrayController.extend({
  sortProperties: [&lsquo;name&rsquo;],
  sortAscending: true // false = descending
});
```</p>

<p>Nous avons simplement trié nos utilisateurs par ordre alphabétique. Consultez
les guides pour en [apprendre plus sur les contrôleurs][GUIDES_CONTROLLERS].</p>

<h3>Afficher le nombre d'utilisateurs</h3>

<p>Utilisons <code>UsersController</code> pour créer notre première propriété calculée
([computed property][COMPUTED_PROPERTY]). Celle-ci affichera le nombre
d'utilisateurs pour que nous puissions voir un changement lors de l'ajout ou de
la suppression d'un utilisateur.</p>

<p>Dans le {l-en template}, il nous suffit d'utiliser ceci :</p>

<p>``` html
/<em> /templates/users.hbs
</em>/
…</p>

<div>Utilisateurs: {{usersCount}}</div>


<p>…
```</p>

<p>Déclarons ensuite la propriété <code>usersCount</code> dans <code>UsersController</code> à la
différence que ce n'est pas une propriété classique puisqu'elle dépend de la
longueur du modèle.</p>

<pre><code class="javascript">/* /controllers/usersController.js
*/
App.UsersController = Em.ArrayController.extend({
  …
  usersCount: function(){
    return this.get('model.length');
  }.property('@each')
});
</code></pre>

<p>Pour faire simple, <code>usersCount</code> utilise la méthode <code>.property('@each')</code> qui
indique à {l-en Ember.js} que cette fonction est une propriété qui observe tout
changement sur l'un des modèles de la collection (ici les utilisateurs). Nous
verrons ensuite <code>usersCount</code> s'incrémenter ou se décrémenter chaque fois que
nous ajouterons ou supprimerons un utilisateur.</p>

<h3>Propriétés calculées</h3>

<p>Les propriétés calculées sont puissantes. Elles permettent de déclarer des
fonctions en tant que propriétés. Voyons comment elles fonctionnent.</p>

<pre><code class="javascript">App.Person = Ember.Object.extend({
  firstName: null,
  lastName: null,

  fullName: function() {
    return this.get('firstName') + ' ' + this.get('lastName');
  }.property('firstName', 'lastName')
});

var ironMan = App.Person.create({
  firstName: "Tony",
  lastName:  "Stark"
});

ironMan.get('fullName') // "Tony Stark"
</code></pre>

<p>Dans l'exemple ci-dessus, l'objet <code>Person</code> a deux propriétés statiques,
<code>firsName</code> et <code>lastName</code>. Il a également une propriétés calculées <code>fullName</code> qui
concatène le prénom et le nom pour créer un nom complet. Notez que l'appel à
<code>.property('firsName', 'lastName')</code> indique que la fonction est de nouveau
exécutée lorsque <code>firsName</code> ou <code>lastName</code> change.</p>

<p>Les propriétés (statiques ou calculées) sont récupérables grâce à la méthode
<code>.get('property')</code> et peuvent être assignées via <code>.set('property', newValue)</code>.</p>

<p>Si vous avez besoin d'assigner plusieurs propriétés, il y a mieux que de le
faire une par une. Vous pouvez utiliser <code>.setProperties({})</code> plutôt que
plusieurs appels à <code>.set()</code>. Au lieu de ceci :</p>

<pre><code class="javascript">this.set('propertyA', 'valueA');
this.set('propertyB', valueB);
this.set('propertyC', 0);
this.set('propertyD', false);

Utilisez plutôt cela :

this.setProperties({
  'propertyA': 'valueA',
  'propertyB': valueB,
  'propertyC': 0,
  'propertyD': false
});
</code></pre>

<p>La documentation contient beaucoup d'informations sur comment lier les données
grâce aux [propriétés calculées][COMPUTED_PROPERTY], aux
<a href="http://emberjs.com/guides/object-model/observers">observers</a> et aux
<a href="http://emberjs.com/guides/object-model/bindings">bindings</a>.</p>

<h3>Rediriger depuis la page Index</h3>

<p>Si vous visitez la page d'accueil de votre application (<code>http://localhost/</code>),
rien ne se passe. Cela est dû au fait que nous consultons la page <code>index</code> et que
nous n'avons pas de {l-en template} <code>index</code>, nous allons donc en ajouter un que
nous appellerons <code>index.hbs</code>.</p>

<p>{l-en Ember.js} sait que vous créez un {l-en template} <code>index</code> pour la route
<code>IndexRoute</code>, vous n'avez donc rien à indiquer dans le <code>Router</code> pour que
tout fonctionne. C'est ce que l'on appelle une route initiale. Il en existe
trois : <code>ApplicationRoute</code>, <code>IndexRoute</code> et <code>LoadingRoute</code>. Consultez
[les guides][INITIAL_ROUTES] pour en savoir plus.</p>

<p>Ajoutons un lien vers la page des utilisateurs avec le {l-en block helper}
<code>{{#link-to}}…{{/link-to}}</code>. Pourquoi un {l-en block helper} ? Parce que vous
pouvez écrire du texte entre les balises comme s'il s'agissait de balises HTML.</p>

<pre><code class="html">/* /templates/index.hbs
*/
{{#link-to "users"}} Go to the users page {{/link-to}}
</code></pre>

<p>Le premier argument est le nom de la route vers laquelle pointe le lien. Le
deuxième argument, optionnel, est un modèle. Le résultat est un <code>&lt;a&gt;</code> classique
mais {l-en Ember} gère automatiquement la classe <code>active</code> en fonction de la
route active. <code>link-to</code> est parfait pour une menu par exemple. Vous pouvez en
apprendre plus <a href="http://emberjs.com/guides/templates/links">dans les guides</a>.</p>

<p>Une autre approche pourrait être de dire à <code>IndexRoute</code> de rediriger vers
<code>UsersRoute</code>. Encore une fois, c'est assez simple :</p>

<pre><code class="javascript">/* /routes/indexRoute.js
*/
App.IndexRoute = Ember.Route.extend({
  redirect: function(){
    this.transitionTo('users');
  }
});
</code></pre>

<p>Lorsque l'on visite la page d'accueil, on est immédiatement redirigé vers
<code>/#/users</code>.</p>

<h3>Route d'un utilisateur spécifique</h3>

<p>Avant de gérer les segments dynamiques, nous devons créer un lien vers chaque
utilisateur depuis le {l-en template} <code>users</code>. Utilisons le {l-en block helper}
<code>{{#link-to}}</code> dans une boucle <code>each</code> qui parcourt les utilisateurs.</p>

<pre><code class="html">/* /templates/users.hbs
*/
…
{{#each user in controller}}
  &lt;li&gt;
    {{#link-to "user" user}}
      {{user.name}}
    {{/link-to}}
  &lt;/li&gt;
{{/each}}
</code></pre>

<p>Le deuxième argument passé à <code>link-to</code> est le modèle à passer à <code>UserRoute</code>.</p>

<p>Occupons-nous maintenant du {l-en template} d'un utilisateur spécifique. Il
ressemble à ceci :</p>

<p>``` html
/<em> /templates/user.hbs
</em>/</p>

<div class="user-profile">
  <img {{bind-attr src="avatarUrl"}} alt="Avatar de l'utilisateur" />
  <h2>{{name}}</h2>
  <span>{{email}}</span>
  <p>{{bio}}</p>
  <span>Création {{creationDate}}</span>
</div>


<pre><code>
Notez que vous ne pouvez pas utiliser `&lt;img src="{{avatarUrl}}"&gt;`, les données
attachées à un attribut doivent utiliser le {l-en helper} `bind-attr`. Vous
pouvez par exemple écrire `&lt;img {{bind-attr height="imgHeight"}}&gt;` avec
`imgHeight` qui serait une propriété calculée dans le contrôleur.

Vous trouverez tout ce dont vous avez besoin sur les
[attributs][GUIDES_ATTRIBUTES] et les
[classes HTML][BINDING_ELEMENT_CLASS_NAMES] dans les guides.

Jusque là, tout va bien mais rien ne se passe lorsque l'on clique sur le lien
d'un utilisateur. Cela est dû au fait que nous avons dit au `Router` que nous
voulions imbriquer `UserRoute` dans `UsersRoute`. Nous avons donc besoin d'un
`{{outlet}}` dans lequel afficher le {l-en template} d'un utilisateur.
</code></pre>

<p>/<em> /templates/users.hbs
</em>/
…
{{#each user in controller}}
…
{{/each}}</p>

<p>{{outlet}}
```</p>

<p><code>{{outlet}}</code> est une sorte d'espace réservé dans lequel les autres
{l-en templates} peuvent être injectés lorsque l'on clique sur un
<code>{{#link-to}}</code>. Cela permet d'imbriquer les vues.</p>

<p>Vous devriez maintenant voir le {l-en template} d'un utilisateur s'afficher dans
la page lorsque vous visitez l'URL <code>/#/users/1</code>.</p>

<p>Attendez une minute ! Nous n'avons déclaré ni <code>UserRoute</code> ni <code>UserController</code> et
pourtant tout fonctionne ! Comment est-ce possible ? <code>UserRoute</code> est la version
singulière de <code>UsersRoute</code>, {l-en Ember} génère donc la route et le contrôleur
pour nous (en mémoire). Merci aux conventions de nommage !</p>

<p>Pour une question de consistance, nous allons les déclrarer, juste pour voir à
quoi il ressemblent :</p>

<pre><code class="javascript">/* /routes/userRoute.js
*/
App.UserRoute = Ember.Route.extend({
  model: function(params) {
    return this.store.find('user', params.user_id);
  }
});

/* /controllers/userController.js
*/
App.UserController = Ember.ObjectController.extend();
</code></pre>

<p>Pour en apprendre plus sur les [segments dynamiques][DYNAMIC_SEGMENTS],
rendez-vous dans les guides.</p>

<h3>Modifier un utilisateur</h3>

<p>Passons maintenant au formulaire de modification d'un utilisateur, imbriqué dans
la page de ce dernier. Le {l-en template} ressemble à ceci :</p>

<p>``` html
/<em> /templates/user/edit.hbs
</em>/</p>

<div class="user-edit">
  <label>Choisissez votre avatar</label>
  {{input value=avatarUrl}}

  <label>Nom de l'utilisateur</label>
  {{input value=name}}

  <label>Email de l'utilisateur</label>
  {{input value=email}}

  <label>Bio de l'utilisateur</label>
  {{textarea value=bio}}
</div>


<pre><code>
Arrêtons-nous une minute sur ces balises [`{{input}}`][INPUT_HELPER]. Le but de
ce formulaire est de permettre la modification des données d'un utilisateur et
ces balises `input` prennent en paramètre les propriétés du modèle pour s'y
attacher.

Notez bien que l'on écrit `value=model`, sans les `" "`. Le {l-en helper}
`{{input}}` est un raccourcis pour `{{Ember.TextField}}`. {l-en Ember.js}
propose plusieurs
[vues prédéfinies](http://emberjs.com/guides/views/built-in-views), en
particulier pour les éléments de formulaires.

Si vous visitez l'URL `/#/users/1/edit` de votre application, rien ne se passe.
Nous avons de nouveau besoin d'un `{{outlet}}` pour imbriquer le {l-en template}
du formulaire dans celui de l'utilisateur.
</code></pre>

<p>/<em> /templates/user.hbs
</em>/
…
{{outlet}}
```</p>

<p>Le {l-en template} est maintenant injecté dans la page mais les champs sont
toujours vides. Nous devons dire à la route quel modèle utiliser.</p>

<pre><code class="javascript">/* /routes/userEditRoute.js
*/
App.UserEditRoute = Ember.Route.extend({
  model: function(){
    return this.modelFor('user');
  }
});
</code></pre>

<p>La méthode
<a href="http://emberjs.com/api/classes/Ember.Route.html#method_modelFor">modelFor</a> vous
permet d'utiliser le modèle d'une autre route. Nous avons indiqué à
<code>UserEditRoute</code> d'utiliser le modèle de <code>UserRoute</code>. Les champs sont maintenant
remplis correctement avec les données du modèle. Essayez de les modifier, vous
pourrez voir les modifications reportées en direct dans le {l-en template}
parent !</p>

<h3>Notre première action</h3>

<p>Ok, nous avons besoin d'un bouton sur lequel cliquer pour être redirigé de
<code>UserRoute</code> vers <code>UserEditRoute</code>.</p>

<p>``` html
/<em> /templates/user.hbs
</em>/</p>

<p><div class="user-profile">
  <button {{action "edit"}}>Modifier</button>
  …
```</p>

<p>Nous venons d'ajouter un simple <code>button</code> qui lance notre première <code>{{action}}</code>.
Les actions sont des événements qui lancent les méthodes associées dans le
contrôleur courant.  Si aucune méthode n'est trouvée, l'action remonte
({l-en bubble}) les routes jusqu'à trouver quelque chose. Ce mécanisme est très
bien expliqué [dans les guides][ACTION_BUBBLING].</p>

<p>En d'autres termes, si nous cliquons (<code>click</code>) sur le <code>button</code>, il va lancer
l'action <code>edit</code> qui se trouve dans le contrôleur. Ajoutons-la à
<code>UserController</code> :</p>

<pre><code class="javascript">/* /controllers/userController.js
*/
App.UserController = Ember.ObjectController.extend({
  actions: {
    edit: function(){
      this.transitionToRoute('user.edit');
    }
  }
});
</code></pre>

<p>Les actions, que ce soit dans un contrôleur ou une route, sont stockées dans
le {l-en hash} <code>actions</code>. Ce n'est cependant pas le cas des actions par défaut
comme <code>click</code>, <code>doubleClick</code>, <code>mouseLeave</code> ou <code>dragStart</code>. Le site
d'{l-en Ember.js} contient la
<a href="http://emberjs.com/api/classes/Ember.View.html#toc_event-names">liste complète</a>
de ces actions.</p>

<p>Notre action <code>edit</code> dit simplement &ldquo;Va sur la route <code>user.edit</code>&rdquo;. C'est à peu
près tout.</p>

<h3>TransitionTo ou TransitionToRoute ?</h3>

<p>Notez que la transition depuis une route est différente de la transition depuis
un contrôleur :</p>

<pre><code class="javascript">// depuis une route
this.transitionTo('your.route')
// depuis un contrôleur
this.transitionToRoute('your.route')
</code></pre>

<h3>Sauvegarder les modifications apportées à l'utilisateur</h3>

<p>Voyons maintenant comment sauvegarder nos modifications après avoir changé la
valeur des données de l'utilisateur. Par sauvegarder, j'entends rendre
persistant. Avec {l-en Ember-Data}, cela signifie d'appeler <code>save()</code> sur le
<code>Store</code> et de sauvegarder le nouveau <code>record</code> correspondant à l'utilisateur.
Le <code>Store</code> va ensuite dire à l'<code>adapter</code> d'effectuer une requête AJAX {l-en PUT}
(si vous utilisez <code>RESTAdapter</code>).</p>

<p>Dans notre application, il s'agit d'un <code>button</code> &ldquo;OK&rdquo; qui sauvegarde les
modifications et retourne à la route parente. Nous allons à nouveau utiliser
une <code>{{action}}</code>.</p>

<pre><code class="html">/* /templates/user/edit.hbs
*/
&lt;button {{action "save"}}&gt; ok &lt;/button&gt;
</code></pre>

<pre><code class="javascript">/* /controllers/userEditController.js
*/
App.UserEditController = Ember.ObjectController.extend({
  actions: {
    save: function(){
      var user = this.get('model');
      // cela indique à Ember-Data de sauvegarder le nouvel enregistrement
      user.save();
      // puis transite vers l'utilisateur courant
      this.transitionToRoute('user', user);
    }
  }
});
</code></pre>

<p>Notre mode &ldquo;modification&rdquo; fonctionne bien. Passons maintenant à la suppression
d'un utilisateur.</p>

<h3>Supprimer un utilisateur</h3>

<p>Nous pouvons ajouter un <code>button</code> &ldquo;Supprimer&rdquo; à côté du bouton &ldquo;Modifier&rdquo; dans le
{l-en template} d'un utilisateur. Cette fois nous aurons une <code>{{action}}</code>
<code>delete</code> définie dans <code>UserController</code>.</p>

<pre><code class="html">/* /templates/user.hbs
*/
&lt;button {{action "delete"}}&gt;Supprimer&lt;/button&gt;
</code></pre>

<pre><code class="javascript">/* /controllers/userController.js
*/
…
actions: {
  delete: function(){
    // ceci indique à Ember-Data de supprimer l'utilisateur courant
    this.get('model').deleteRecord();
    this.get('model').save();
    // puis transite vers la route users
    this.transitionToRoute('users');
  }
}
</code></pre>

<p>Lorsque l'on clique sur le bouton &ldquo;Supprimer&rdquo;, l'utilisateur est directement
supprimé. Un peu direct ; un message de confirmation comme &ldquo;Êtes-vous sûr ?&rdquo;
avec des boutons &ldquo;Oui&rdquo; et &ldquo;Non&rdquo; seraient bienvenus. Pour ce faire, nous devons
modifier notre <code>{{action "delete"}}</code> pour afficher <code>confirm-box</code> plutôt que de
supprimer immédiatement l'utilisateur. Et, bien sûr, nous devons mettre
<code>confirm-box</code> dans le {l-en template} <code>user</code>.</p>

<pre><code class="html">/* /templates/user.hbs
*/
{{#if deleteMode}}
&lt;div class="confirm-box"&gt;
  &lt;h4&gt;Sûr ?&lt;/h4&gt;
  &lt;button {{action "confirmDelete"}}&gt; oui &lt;/button&gt;
  &lt;button {{action "cancelDelete"}}&gt; non &lt;/button&gt;
&lt;/div&gt;
{{/if}}
</code></pre>

<p>Nous venons d'écrire notre premier <code>{{if}}</code> avec {l-en Handlebars}. Il n'écrit
<code>div.confirm-box</code> que lorsque la propriété <code>deleteMode</code> est à <code>true</code>. Nous
devons définir <code>deleteMode</code> dans le contrôleur et modifier l'action <code>delete</code>
pour qu'il passe <code>deleteMode</code> à <code>true</code> ou <code>false</code>. Notre <code>UserController</code>
ressemble maintenant à ceci :</p>

<pre><code class="javascript">/* /controllers/userController.js
*/
App.UserController = Ember.ObjectController.extend({
  // la propriété deleteMode est à false par défaut
  deleteMode: false,

  actions: {
    delete: function(){
      // notre méthode delete change uniquement la valeur de deleteMode
      this.toggleProperty('deleteMode');
    },
    cancelDelete: function(){
      // remet deleteMode à false
      this.set('deleteMode', false);
    },
    confirmDelete: function(){
      // ceci indique à Ember-Data de supprimer l'utilisateur courant
      this.get('model').deleteRecord();
      this.get('model').save();
      // puis transite vers la route users
      this.transitionToRoute('users');
      // et remet deleteMode à false
      this.set('deleteMode', false);
    },
    // le méthode edit reste la même
    edit: function(){
      this.transitionToRoute('user.edit');
    }
  }
});
</code></pre>

<p>La suppression fonctionne maintenant comme il faut avec les boutons &ldquo;Oui&rdquo; et
&ldquo;Non&rdquo;. Génial ! Il ne reste plus que la route de création à écrire.</p>

<h3>Créer un utilisateur</h3>

<p>Pour la création de l'utilisateur, essayons quelque chose de fun : réutilisons
le {l-en template} <code>edit</code>. Au final, le formulaire est exactement le même que
celui de modification d'un utilisateur. Commençons par déclarer la route qui va
retourner un objet vide dans son {l-en hook} <code>model</code> :</p>

<pre><code class="javascript">/* /routes/usersCreateRoute.js
*/
App.UsersCreateRoute = Ember.Route.extend({
  model: function(){
    // le modèle de cette route est un nouvel Ember.Object vide
    return Em.Object.create({});
  },

  // dans le cas présent (la route create), nous pouvons réutiliser le template
  // user/edit associé avec usersCreateController
  renderTemplate: function(){
    this.render('user.edit', {
      controller: 'usersCreate'
    });
  }
});
</code></pre>

<p>La méthode <code>renderTemplate</code> nous permet d'associer un {l-en template} spécifique
à une route. Nous indiquons à <code>UsersCreateRoute</code> d'utiliser le {l-en template}
<code>user.edit</code> avec <code>UsersCreateController</code>. Vous pouvez en apprendre plus sur
<code>renderTemplate</code>
<a href="http://emberjs.com/guides/routing/rendering-a-template/">dans les guides</a>.</p>

<p>Définissons maintenant une autre action <code>save</code>, mais dans
<code>UsersCreateController</code> cette fois (souvenez-vous qu'une <code>action</code> va d'abord
chercher une méthode correspondante dans le contrôleur <em>courant</em>).</p>

<pre><code class="javascript">/* /controllers/usersCreateController.js
*/
App.UsersCreateController = Ember.ObjectController.extend({
  actions: {
    save: function(){
      // nous donnons une date de création juste avant la sauvegarde
      this.get('model').set('creationDate', new Date());

      // crée un nouvel enregistrement et le sauvegarde dans le Store
      var newUser = this.store.createRecord('user', this.get('model'));
      newUser.save();

      // redirige vers l'utilisateur lui-même
      this.transitionToRoute('user', newUser);
    }
  }
});
</code></pre>

<p>Ajoutons maintenant un <code>{{#link-to}}</code> dans le {l-en template} <code>users</code> pour
pouvoir accéder au formulaire de création :</p>

<pre><code class="html">/* /templates/users.hbs
*/
{{#link-to "users.create" class="create-btn"}} Ajouter un utilisateur {{/link-to}}
…
</code></pre>

<p>C'est tout ce dont nous avons besoin pour créer des utilisateurs !</p>

<h3>Formater les données avec les {l-en helpers}</h3>

<p>Nous avons <a href="#helpers">déjà vu</a> ce que sont les {l-en helpers}. Voyons maintenant
comment en créer un qui nous permette de formater une date toute moche en
quelque chose de plus propre. La bibliothèque [Moment.js][MOMENTJS] est
exactement ce dont nous avons besoin.</p>

<p>Récupérez [Moment.js][MOMENTJS] et chargez le dans la page. Nous allons ensuite
définir notre premier {l-en helper} :</p>

<pre><code class="javascript">/* /helpers/helpers.js
*/
Ember.Handlebars.helper('formatDate', function(date){
  return moment(date).fromNow();
});
</code></pre>

<p>Modifions le {l-en template} <code>user</code> pour qu'il fasse appel au {l-en helper}
<code>formatDate</code> sur la propriété <code>{{creationDate}}</code> :</p>

<pre><code class="html">/* /templates/user.hbs
*/
…
&lt;span&gt;Création {{formatDate creationDate}}&lt;/span&gt;
…
</code></pre>

<p>C'est tout ! Les dates devraient s'afficher sous la forme &ldquo;2 days ago&rdquo; (il y a
deux jours), &ldquo;One month ago&rdquo; (il y a un mois), etc.</p>

<p><abbr title="Note du traducteur">NDT</abbr> : Moment.js permet d'utiliser
d'autres langues que l'anglais, tout est expliqué
<a href="http://momentjs.com/docs/#/i18n/">dans la documentation</a>.</p>

<h3>Formater les données avec un {l-en BoundHelper}</h3>

<p>Dans le cas précédent, la date est fixe et ne risque pas de changer. Si nous
avons par contre des données qui doivent être mises à jour (par exemple un
prix formaté), il faut utiliser un <code>BoundHelper</code> au lien d'un {l-en helper}
classique.</p>

<pre><code class="javascript">/* /helpers/helpers.js
*/
Ember.Handlebars.registerBoundHelper('formatDate', function(date){
  return moment(date).fromNow();
});
</code></pre>

<p>Un <code>BoundHelper</code> sait se mettre à jour automatiquement lorsque les données
changent. Vous pouvez en apprendre plus sur le sujet
[dans les guides][BOUND_HELPER].</p>

<h3>Passer au {l-en LocalStorage Adapter}</h3>

<p>Notre application fonctionne bien, nous sommes donc prêts à passer aux choses
sérieuses. Nous pourrions utiliser le <code>RESTAdapter</code> mais nous aurions du coup
besoin d'un server REST sur lequel effectuer des requêtes <code>GET</code>, <code>PUT</code>, <code>POST</code>
et <code>DELETE</code>. Nous allons plutôt utiliser le <code>LSAdapter</code>, un {l-en adapter}
externe que vous pouvez [télécharger sur GitHub][LSAdapter]. Ajoutez-le dans
votre page (juste après {l-en Ember-Data}), commentez toutes les données
<code>FIXTURE</code> et changez <code>ApplicationAdapter</code> pour <code>DS.LSAdapter</code> :</p>

<pre><code class="javascript">/* /store.js
*/
App.ApplicationAdapter = DS.LSAdapter;
</code></pre>

<p>Les données de vos utilisateurs seront maintenant stockées dans le
{l-en local storage} (stockage local du navigateur). C'est tout ! Sérieusement,
c'est aussi simple que ça. Pour vous en assurer, ouvrez les
{l-en Developer Tools} dans votre navigateur et rendez-vous dans le panneau
&ldquo;Ressource&rdquo;. Dans l'onglet &ldquo;Local Storage&rdquo; vous devriez trouver une entrée pour
<code>LSAdapter</code> avec toutes les données de vos utilisateurs.</p>

<p><img src="/images/ember/console-localstorage.png" alt="console-localstorage" /></p>

<h2>Jouer avec les vues</h2>

<p>Jusque là, nous n'avons déclaré aucune vue dans notre application, seulement des
{l-en templates}. Pourquoi nous soucier des vues ? Et bien, elles sont très
puissantes pour gérer des événements, des animations ou des composants
réutilisables.</p>

<h3>jQuery et {l-en didInsertElement}</h3>

<p>Que devons-nous faire pour utiliser jQuery comme d'habitude avec les vues
{l-en Ember.js} ? Chaque vue ou composant a un {l-en hook} <code>didInsertElement</code>
qui nous indique que la vue a effectivement été chargée dans le DOM. Cela vous
assure un accès aux éléments de la page depuis jQuery.</p>

<pre><code class="javascript">App.MyAwesomeComponent = Em.Component.extend({
  didInsertElement: function(){
    // this = la vue
    // this.$() = $(la vue)
    this.$().on('click', '.child .elem', function(){
      // quelque chose utilisant jQuery
    });
  }
});
</code></pre>

<p>Si vous avez des événements du style jQuery enregistrés dans <code>didInsertElement</code>,
vous pouvez utiliser <code>willDestroyElement</code> pour les retirer après la suppression
d'une vue dans le DOM, comme ceci :</p>

<pre><code class="javascript">App.MyAwesomeComponent = Em.Component.extend({
  didInsertElement: function(){
    this.$().on('click', '.child .elem', function(){
      // quelque chose utilisant jQuery
    });
  },
  willDestroyElement: function(){
    this.$().off('click');
  }
});
</code></pre>

<h3>Panneaux latéraux avec className dynamique</h3>

<p>La combinaison des propriétés calculées et de classes (<code>className</code>) dynamiques
peut sembler une technique un peu folle mais ce n'est pas si terrible en
réalité. L'idée est simplement d'ajouter ou de retirer une classe CSS sur un
élément en fonction d'une propriété qui peut être <code>true</code> ou <code>false</code>. La classe
CSS contient bien sûr une transition CSS.</p>

<p>Mettons que nous avons une <code>div</code> cachée dans le DOM. Lorsque cette <code>div</code> a la
classe <code>opened</code>, elle s'affiche en glissant. Lorsqu'elle a la classe <code>closed</code>,
elle glisse de nouveau pour se cacher. Un panneau latéral est l'exemple parfait,
nous allons donc en écrire un.</p>

<p>Voici un JS Bin pour que vous puissiez tester le code :</p>

<p><a class="jsbin-embed" href="http://emberjs.jsbin.com/utimiZI/88/embed?js,output">Panneaux latérales réutilisables avec Ember.js - Smashing</a></p>

<p>Voici le détail de chaque onglet :</p>

<ul>
<li><strong>JavaScript</strong><br />
Nous commençons par déclarer notre <code>SidePanelComponent</code> avec des <code>classNames</code>
par défaut. Nous utilisons ensuite <code>classNameBindings</code> pour déterminer si
<code>isOpen</code> est à <code>true</code> ou <code>false</code> de façon à retourner <code>opened</code> ou <code>closed</code> en
fonction. Notre <code>component</code> a une action <code>toggleSidepanel</code> qui passe <code>isOpen</code>
à <code>true</code> ou <code>false</code>.</li>
<li><strong>HTML</strong><br />
Les balises du panneau latéral. Vous remarquerez le bloc
<code>{{#side-panel}}…{{/side-panel}}</code>, nous pouvons placer n'importe quoi dedans
ce qui rend notre panneau latéral extrêmement puissant et réutilisable. Le
bouton <code>btn-toggle</code> appelle l'action <code>toggleSidepanel</code> située dans le
composant. Le <code>{{#if isOpen}}</code> ajoute un peu de logique en vérifiant la valeur
de la propriété <code>isOpen</code>.</li>
<li><strong>CSS</strong><br />
Ici le but principal est de masquer le panneau latéral. La classe <code>opened</code>
le fait glisser en position ouverte et la classe <code>closed</code> le fait glisser dans
l'autre sens. L'animation est rendue possible parce que nous utilisons
<code>translate2D</code> (<code>transition:transform .3s ease</code>).</li>
</ul>


<p>Les guides contiennent de nombreux exemples sur comment lier des classes
[dans les composants][COMPONENTS_ELEMENT] ou
[dans les {l-en templates}][BINDING_ELEMENT_CLASS_NAMES].</p>

<h3>{l-en Modals} avec {l-en layout} et remontée d'événements</h3>

<p>Cette technique est bien plus compliquée que la précédente. Elle implique bien
plus de fonctionnalités d'{l-en Ember.js}. L'idée est de faire remonter un
événement d'une vue jusqu'à la route pour changer une propriété située dans un
contrôleur quelque part dans l'application. Nous allons utiliser une <code>View</code>
plutôt qu'un <code>Component</code> (pour mémoire, un composant est simplement une vue
isolée).</p>

<p><a class="jsbin-embed" href="http://emberjs.jsbin.com/aKUWUF/55/embed?js,output">Modals réutilisables avec Ember.js - Smashing</a></p>

<ul>
<li><strong>JavaScript</strong><br />
<code>modalView</code> est le <code>layout</code> par défaut pour toutes nos {l-en modals}. Elle
contient deux méthodes, <code>showModal</code> et <code>hideModal</code>. La méthode <code>showModal</code> est
appelée par une <code>action</code> qui remonte, en passant par le contrôleur puis par
les routes, jusqu'à trouver l'action <code>showModal</code> correspondante. Nous avons
placé <code>showModal</code> dans la route la plus haute possible, <code>applicationRoute</code>.
Son seul but est de valuer la propriété <code>modalVisible</code> dans le contrôleur
passé en second argument de l'<code>action</code>. Et oui, créer une propriété en même
temps qu'on lui donne sa valeur est possible.</li>
<li><strong>HTML</strong><br />
Chaque {l-en modal} a son propre {l-en template} et nous utilisons le bloc
<code>{{#view App.ModalView}}…{{/view}}</code> pour les encapsuler dans <code>modal_layout</code>.
Les contrôleurs liés aux {l-en modals} ne sont même pas déclarés,
{l-en Ember.js} les a en mémoire. Notez que le {l-en helper} <code>{{render}}</code>
accepte des arguments : le nom du {l-en template} et le contrôleur généré pour
ce {l-en template}. Nous appelons par exemple le {l-en template} <code>modal01</code> et
le contrôleur <code>modal01</code> (auto-généré).</li>
<li><strong>CSS</strong><br />
Pour cet exemple, les {l-en modals} doivent être présentes dans le DOM. Cela
peut sembler contraignant mais réduit le coût d'affichage. Sans cela,
{l-en Ember.js} doit les injecter et les supprimer à chaque appel. Le second
avantage concerne les transitions CSS. La classe <code>shown</code> applique deux
transition : tout d'abord, la position verticale (la {l-en modal} étant en
dehors de l'écran par défaut), puis, après un court délai, l'opacité (ce qui
[réduit][SPDECK_HW_ACCELERATION] encore le [coût][CSS_TRICKS_HW_ACCELERATION]
d'affichage durant la transition).</li>
</ul>


<p>Vous trouverez bien d'autres informations sur les
<a href="http://emberjs.com/guides/views/handling-events">événements</a>,
[la remontée d'événements][EVENTS_BUBBLING], les
<a href="http://emberjs.com/guides/views/adding-layouts-to-views">layouts</a> et le
{l-en helper} [{{render}}][RENDER_HELPER] dans les guides.</p>

<h2>Qu'est-ce qu'{l-en Ember-Data}</h2>

<p>{l-en Ember-Data} est en beta au moment où j'écris ces lignes, faites donc
attention si vous décidez de l'utiliser.</p>

<p>C'est une bibliothèque qui permet de récupérer les données
stockées sur le serveur, de les retenir dans un <code>Store</code>, de les mettre à jour
dans le navigateur et enfin des les renvoyer au serveur pour sauvegarde. Le
<code>Store</code> peut être configuré avec différents {l-en adapters} en fonction de votre
{l-en back-end}. Voici un schéma de l'architecture d'{l-en Ember-data}.</p>

<p><img src="/images/ember/ember-data-sketch.png" alt="ember-data-sketch" /></p>

<h3>Le {l-en store}</h3>

<p>Le <code>Store</code> retient les informations chargées depuis le serveur (les
enregistrements). Les routes et contrôleurs peuvent effectuer des requêtes sur
le <code>Store</code> pour récupérer des enregistrements ({l-en records}). Lorsqu'un
enregistrement est appelé pour la première fois, le <code>Store</code> demande à
l'{l-en adapter} de le charger au travers du réseau. Le <code>Store</code> le garde ensuite
en {l-en cache} pour les prochains appels.</p>

<h3>Les {l-en adapters}</h3>

<p>L'application effectue des requêtes sur le <code>Store</code> et l'{l-en adapter} effectue
des requêtes sur le {l-en back-end}. Chaque {l-en adapter} est fait pour un
{l-en back-end} particulier. On trouve par exemple le <code>RESTAdapter</code> qui permet
de communiquer avec un API JSON et le <code>LSAdapter</code> qui permet d'utiliser le
{l-en local storage} du navigateur.</p>

<p>L'idée derrière {l-en Ember-Data} est de pouvoir changer de {l-en back-end} en
changeant simplement l'{l-en adapter} sans changer le code de votre application.</p>

<ul>
<li>{l-en FixtureAdapter}<br />
Le <code>FixtureAdapter</code> est parfait pour tester {l-en Ember} et {l-en Ember-Data}.
Les {l-en fixtures} sont des données d'exemple avec lesquelles vous pouvez
travailler jusqu'à ce que votre application soit prête pour la production.
Nous avons vu [plus tôt dans cet article][FIXTURE_ADAPTER] comment le
configurer.</li>
<li><p>{l-en RESTAdapter}<br />
Le <code>RESTAdapter</code> est l'{l-en adapter} par défaut dans {l-en Ember-Data}. Il
permet d'effectuer des requêtes <code>GET</code>, <code>PUT</code>, <code>POST</code> et <code>DELETE</code> sur une API
REST. Il repose sur un certain nombre de
[conventions JSON spécifiques][JSON_CONVENTIONS]. Utiliser cet {l-en adapter}
se fait comme ceci :</p>

<p><code>App.ApplicationAdapter = DS.RESTAdapter.extend({
  host: 'https://your.api.com'
});</code><br /></p>

<p>Il y a bien plus à découvrir sur le <code>RESTAdapter</code>
<a href="http://emberjs.com/guides/models/the-rest-adapter">dans les guides</a>.</p></li>
<li><p>{l-en Adapter} personnalisé<br />
Vous pouvez utiliser un autre {l-en adapter} que les deux par défaut
(<code>FixtureAdapter</code> et <code>RESTAdapter</code>). On en trouve bon nombre
<a href="https://github.com/search?q=ember+adapter&amp;amp;ref=reposearch">sur Github</a>.
Il y a, par exemple, l'[{l-en adapter} LocalStorage][LSAdapterGihub] dont on
peut trouver une démo dans la
<a href="http://emberjs.com/guides/getting-started/using-other-adapters">{l-en Todo}</a>
d'exemple des guides. Je l'utilise également dans la [démo][STYLED_DEMO].</p></li>
</ul>


<h3>Sans utiliser {l-en Ember-Data}</h3>

<p>Dans cet article, j'ai choisi de parler d'{l-en Ember-Data} parce qu'il est
presque prêt et que c'est un des trucs les plus cool qui ont lieu dans le monde
JavaScript en ce moment. Vous vous demandez peut être s'il est possible de s'en
passer. La réponse est oui ! En fait, utiliser {l-en Ember.js} sans
{l-en Ember-Data} est assez facile.</p>

<p>Il y a deux façons de le faire.</p>

<p>Vous pouvez utiliser d'autres bibliothèques pour prendre en charge la
récupération et la persistance de vos modèles.
<a href="https://github.com/ebryn/ember-model">Ember-Model</a>,
<a href="https://github.com/zendesk/ember-resource">Ember-Resource</a>,
<a href="https://github.com/endlessinc/ember-restless">Ember-Restless</a> et, plus
récemment, <a href="http://epf.io/">EPF</a> sont de bonnes alternatives. {l-en EmberWatch}
a rédigé un petit articles qui liste les
&ldquo;[Alternatives à {l-en Ember-Data}][ALTERNATIVES_TO_ED]&rdquo;.</p>

<p>Une autre façon de faire pourrait être de ne pas utiliser de bibliothèque. Dans
ce cas, vous devez implémenter les méthodes de récupération des modèles via
requêtes AJAX. &ldquo;[{l-en Ember Without Ember-Data}][EMBER_WO_ED]&rdquo;, par Robin Ward
(le mec derrière <a href="http://www.discourse.org/">Discourse</a>), est une lecture
intéressante. &ldquo;[{l-en Getting Into Ember.js, Part 3}][TUTPLUS_EMBER]&rdquo;, par Rey
Bango sur Nettuts+ traite en particulier des modèles.</p>

<p>Voici par exemple comment définir une méthode statique sur un modèle en
utilisant <code>reopenClass</code> :</p>

<pre><code class="javascript">/* /models/user.js
*/
// our own findStuff method inside the User model
App.User.reopenClass({
  findStuff: function(){
    // utilise une requête AJAX / Promises classique
    return $.getJSON("http://your.api.com/api").then(function(response) {
      var users = [];
      // crée de nouveaux Ember Objects et les stocke dans le tableau users
      response.users.forEach(function(user){
        users.push( App.User.create(user) );
      });
      // retourne le tableau plein d'Ember Objects
      return users;
    });
  }
});
</code></pre>

<p>Vous pouvez ensuite utiliser la méthode <code>findStuff</code> dans le {l-en hook} <code>model</code>
de nos routes :</p>

<pre><code class="javascript">/* /routes/usersRoute.js
*/
App.UsersRoute = Em.Route.extend({
  model: function(){
    return App.User.findStuff();
  }
});
</code></pre>

<h2>Qu'est-ce que la précompilation de {l-en templates} {l-en Handlebars} ?</h2>

<p>Pour faire simple, précompiler les {l-en templates} veut dire prendre tous les
{l-en templates} et les transposer en chaines de caractères JavaScript puis les
stocker dans <code>Ember.TEMPLATES</code>. Cela veut également dire qu'il y a un fichier en
plus, contenant la version compilée de tous vos {l-en templates}
{l-en Handlebars}, à charger dans votre page.</p>

<p>Pour une application assez simple, la précompilation peut être évitée. Si vous
avez cependant trop de {l-en templates} <code>&lt;script type="text/x-handlebars"&gt;</code> dans
votre principal fichier HTML, la précompilation vous permettra de mieux
organiser votre code.</p>

<p>De plus, précompiler vos {l-en templates} vous permet d'utiliser la version
{l-en runtime} de {l-en Handlebars} qui est plus légère que la version
classique. Vous pouvez trouver les deux versions (standard et {l-en runtime})
sur le [site de {l-en Handlebars}][HANDLEBARS].</p>

<h3>Conventions de nommage des {l-en templates}</h3>

<p>Les [partials][GUIDES_PARTIALS] doivent commencer par un <code>_</code>. Vous devez donc
déclarer un fichier <code>_yourpartial.hbs</code> ou, si vous ne précompilez pas vos
{l-en templates}, une balise
<code>&lt;script type="text/x-handlebars" id="_yourpartial"&gt;</code>.</p>

<p>Les [composants][GUIDES_PARTIALS]
doivent commencer par <code>components/</code>. Vous devez donc les stocker dans un dossier
<code>components/</code> ou, si vous ne précompilez pas vos {l-en templates}, une
balise <code>&lt;script type="text/x-handlebars" id="components/votre-composant"&gt;</code>. Vous
devez utiliser un tiret comme séparateur dans le nom des composants.</p>

<p>Vous pouvez cependant utiliser une propriété <code>templateName</code> dans les vues pour
spécifier quel {l-en template} associer avec une vue. Voici une déclaration de
{l-en template} :</p>

<pre><code class="javascript">&lt;script type="text/x-handlebars" id="folder/some-template"&gt;
  Un template
&lt;/script&gt;
</code></pre>

<p>Que vous pouvez associer à une vue particulière :</p>

<pre><code class="javascript">App.SomeView = Em.View.extend({
  templateName: 'folder/some-template'
});
</code></pre>

<h3>Précompiler avec {l-en Grunt}</h3>

<p>Si vous utilisez [Grunt][GRUNT], vous vous en servez probablement pour d'autres
tâches liées à la construction (concatenation, compression, ce genre de choses).
Dans ce cas, vous devez connaitre le fichier <code>package.json</code> qui vient avec
{l-en Node.js} et les modules {l-en Node}. Je vais considérer que vous
connaissez déjà Grunt.</p>

<p>Au moment où j'écris ceci, deux {l-en plugins} Grunt sont disponibles pour
transposer vos fichiers <code>.hbs</code> en fichier <code>templates.js</code> :
<a href="https://github.com/yaymukund/grunt-ember-handlebars">grunt-ember-handlebars</a> et
<a href="https://github.com/dgeb/grunt-ember-templates">grunt-ember-templates</a>. Le
deuxième semble un peu plus à jour que le premier.</p>

<p>J'ai écris un {l-en Gist} pour chacun d'eux, pour vous aider avec la
configuration :</p>

<ul>
<li>[Voir le {l-en Gist} pour {l-en grunt-ember-handlebars}][GRUNT_EMBER_HB] ;</li>
<li>[Voir le {l-en Gist} pour {l-en grunt-ember-templates}][GRUNT_EMBER_TPL].</li>
</ul>


<p>Une fois configurés, vous devriez être à même de lancer <code>grunt</code> en ligne de
commande et cela devrait produire le fichier <code>templates.js</code>. Chargez-le dans
<code>index.html</code> (après <code>ember.js</code>) puis rendez-vous dans la console du navigateur
et tapez <code>Em.TEMPLATES</code>. Vous devriez voir un {l-en hash} contenant tous les
{l-en templates} compilés.</p>

<p>Notez qu'{l-en Ember.js} n'a pas besoin du chemin complet vers un
{l-en template} ni l'extension du fichier. En d'autres termes, le nom du
{l-en template} devrait être <code>users/create</code> et non
<code>/assets/js/templates/users/create.hbs</code>.</p>

<p>Les deux {l-en plugins} fournissent des options pour gérer cela. Référez-vous
aux guides respectifs ou jetez un oeil aux {l-en Gists} ci-dessus. Vous devriez
obtenir quelque chose dans ce genre :</p>

<p><img src="/images/ember/console-templates.png" alt="console-templates" /></p>

<p>Exactement ce qu'il nous faut pour que tout marche correctement. C'est tout ce
dont vous avez besoin pour précompiler avec {l-en Grunt}.</p>

<h3>Précompiler avec {l-en Rails}</h3>

<p>Précompiler avec {l-en Rails} est la façon la plus simple de faire. La
<a href="https://github.com/emberjs/ember-rails">{l-en gem} Ember-Rails</a> se charge d'à
peu près tout. Il fonctionne <em>presque</em> {l-en out-of-the-box}. Suivez
attentivement les instructions d'installation du <code>readme</code> sur GitHub et tout
devrait bien se passer. Selon moi, {l-en Rails} a la meilleure intégration
{l-en Ember}/{l-en Handlebars} pour le moment.</p>

<h2>Outils, astuces et ressources</h2>

<h3>L'Extension Chrome {l-en Ember}</h3>

<p>L'[Extension {l-en Ember}][EMBER_INSPECTOR] pour Chrome est très pratique. Une
fois installée, un onglet &ldquo;{l-en Ember}&rdquo; apparait près de l'onglet &ldquo;Console&rdquo;.
Vous pouvez ensuite naviguer à travers vos contrôleurs, routes et vues. L'onglet
&ldquo;{l-en Data}&rdquo; vous permettra d'explorer vos enregistrements très simplement si
vous utilisez {l-en Ember-Data}.</p>

<p>[![console-ember-extension][EXT_SMALL]][EXT_BIG]<br />
<em>Exploring your app’s objects has never been so easy.</em></p>

<h3>{l-en Ember App Kit}</h3>

<p>Le <a href="http://iamstef.net/ember-app-kit/">Ember App Kit</a>, maintenu par l'équipe
{l-en Ember}, vous permet de créer très rapidement une application {l-en Ember}.
Il contient [Grunt][GRUNT] pour compiler les {l-en assets}, le lanceur de tests
<a href="http://karma-runner.github.io/0.10/index.html">Kharma</a>,
<a href="http://bower.io/">Bower</a> et le support des
<a href="http://wiki.ecmascript.org/doku.php?id=harmony:modules">modules ES6</a>.</p>

<h3>{l-en Ember Tools}</h3>

<p>Le projet {l-en GitHub} <a href="https://github.com/rpflorence/ember-tools">Ember Tools</a>
est un outils en ligne de commande pour créer des applications {l-en Ember}.
Prenez une minute pour regarder le {l-en GIF} animé dans le <code>readme</code> et vous
comprendrez pourquoi c'est si cool.</p>

<h3>Développement et version minifié</h3>

<p>Utilisez toujours le {l-en development build} durant le développement, il
contient beaucoup de commentaires, de tests unitaires et un tas de messages
d'erreur utiles qui ont été supprimés dans la version minifié. Vous trouverez un
lien vers chaque version sur le [site d'{l-en Ember.js}][EMBER_BUILDS].</p>

<h3>Astuces pour le {l-en debug}</h3>

<p>{l-en Ember.js} fournit généralement des erreur humainement lisibles dans la
console du navigateur (si vous utilisez bien la version de développement). Il
peut être cependant difficile de deviner d'où vient l'erreur. Quelques méthodes
bien pratiques sont <code>{{log something}}</code> et <code>{{controller}}</code> qui affiche le
<code>controller</code> courant pour le {l-en template} dans lequel nous appelons le
{l-en helper}.</p>

<p>Ou vous pouvez afficher chaque transition du <code>Router</code> comme ceci :</p>

<pre><code class="javascript">window.App = Ember.Application.create({
  LOG_TRANSITIONS: true
});
</code></pre>

<p>Les guides contiennet une
<a href="http://emberjs.com/guides/understanding-ember/debugging">liste exhaustive</a> de
ces petites methodes bien pratiques.</p>

<h3>Commenter correctement dans {l-en Handlebars}</h3>

<p>Celui-là peut être frustrant. Ne commentez <strong>jamais</strong> une balise
{l-en Handlebars} avec un commentaire HTML classique. Si vous le faites, vous
risquez de complètement casser l'application sans même savoir pourquoi.</p>

<pre><code>// ne faites jamais ça
&lt;!-- {{foo}} --&gt;

// faites plutôt ça
{{!foo}}
</code></pre>

<h2>Conclusion</h2>

<p>J'espère que ce long article vous a permis de mieux comprendre cet excellent
{l-en framework}. Mais pour tout vous dire, on a à peine vu la partie émergée de
l'iceberg. Il y a tellement plus à voir. Il y a par exemple le <code>Router</code> et sa
nature asynchrone qui permet de gérer les modèles avec des {l-en promises} (ce
qui permet de créer très facilement un {l-en spinner} de chargement). Il y a
également le modèle objet, avec son héritage de classes ou d'instances, ou
encore les {l-en mixins}, {l-en observers}, filtres, macros, <code>collectionViews</code>
et composants, ou encore la gestion de dépendances entre contrôleurs et le
paquet pour les tests. Et bien plus encore !</p>

<p>Je ne pouvais bien sûr pas vous parler de tout ça. Heureusement, les guides
vous aideront sur tous ces sujets.</p>

<p>{l-en Happy Ember.js coding, folks!}</p>

<h3>Ressources</h3>

<ul>
<li>[Guides {l-en Ember.js}][GUIDES]<br />
Le meilleur endroit pour apprendre {l-en Ember.js}</li>
<li><a href="http://emberjs.com/guides/cookbook/">Ember.js Cookbook</a><br />
Une nouvelle section des guides qui résout plein de problèmes spécifiques</li>
<li><a href="http://emberwatch.com">{l-en EmberWatch}</a><br />
Agrégation de toutes les ressources importantes</li>
<li><a href="http://emberweekly.com/issues.html">{l-en Ember Weekly}</a><br />
Parfait pour rester à jour</li>
<li><a href="http://discuss.emberjs.com">Forum de discussion {l-en Ember.js}</a><br />
C'est ici que les discussions prennent place (et c'est fait avec {l-en Ember})</li>
</ul>


<h3>Remerciements</h3>

<p>Un immense merci à <a href="https://twitter.com/MatBreton">Mathieu Breton</a> et
<a href="https://twitter.com/ficastelli">Philippe Castelli</a> qui m'ont tous deux transmis
tout ce qu'ils savaient sur {l-en Ember.js} durant mon apprentissage. Et un
grand merci à <a href="https://twitter.com/tomdale">Tom Dale</a>, qui m'a aidé à la
relecture de ce bien long article.
</p>

<p><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>[ACTION_BUBBLING]: <a href="http://emberjs.com/guides/templates/actions/#toc_action-bubbling">http://emberjs.com/guides/templates/actions/#toc_action-bubbling</a>
[ALTERNATIVES_TO_ED]: <a href="http://blog.emberwatch.com/2013/06/19/alternatives-ember-data.html">http://blog.emberwatch.com/2013/06/19/alternatives-ember-data.html</a>
[BINDING_ELEMENT_CLASS_NAMES]: <a href="http://emberjs.com/guides/templates/binding-element-class-names">http://emberjs.com/guides/templates/binding-element-class-names</a>
[BOUND_HELPER]: <a href="http://emberjs.com/api/classes/Ember.Handlebars.html#method_registerBoundHelper">http://emberjs.com/api/classes/Ember.Handlebars.html#method_registerBoundHelper</a>
[COMPONENTS_ELEMENT]: <a href="http://emberjs.com/guides/components/customizing-a-components-element">http://emberjs.com/guides/components/customizing-a-components-element</a>
[COMPUTED_PROPERTY]: <a href="http://emberjs.com/guides/object-model/computed-properties/">http://emberjs.com/guides/object-model/computed-properties/</a>
[CSS_TRICKS_HW_ACCELERATION]: <a href="http://css-tricks.com/w3conf-ariya-hidayat-fluid-user-interface-with-hardware-acceleration">http://css-tricks.com/w3conf-ariya-hidayat-fluid-user-interface-with-hardware-acceleration</a>
[CUSTOM_SELECT]: <a href="http://pixelhandler.com/blog/2013/08/25/create-a-custom-select-box-using-ember-component/">http://pixelhandler.com/blog/2013/08/25/create-a-custom-select-box-using-ember-component/</a>
[DYNAMIC_SEGMENTS]: <a href="http://emberjs.com/guides/routing/specifying-a-routes-model/#toc_dynamic-models">http://emberjs.com/guides/routing/specifying-a-routes-model/#toc_dynamic-models</a>
[EMBER_BUILDS]: <a href="http://emberjs.com/builds">http://emberjs.com/builds</a>
[EMBER_FORUM]: <a href="http://discuss.emberjs.com/t/whats-the-difference-between-ember-helpers-components-and-views/2201/2">http://discuss.emberjs.com/t/whats-the-difference-between-ember-helpers-components-and-views/2201/2</a>
[EMBER_WO_ED]: <a href="http://eviltrout.com/2013/03/23/ember-without-data.html">http://eviltrout.com/2013/03/23/ember-without-data.html</a>
[GUIDES]: <a href="http://emberjs.com/guides/">http://emberjs.com/guides/</a>
[GUIDES_ATTRIBUTES]: <a href="http://emberjs.com/guides/templates/binding-element-attributes/">http://emberjs.com/guides/templates/binding-element-attributes/</a>
[GUIDES_CONTROLLERS]: <a href="http://emberjs.com/guides/controllers">http://emberjs.com/guides/controllers</a>
[GUIDES_MODELS]: <a href="http://emberjs.com/guides/models">http://emberjs.com/guides/models</a>
[GUIDES_PARTIALS]: <a href="http://emberjs.com/guides/templates/rendering-with-helpers/">http://emberjs.com/guides/templates/rendering-with-helpers/</a>
[HANDLEBARS]: <a href="http://handlebarsjs.com">http://handlebarsjs.com</a>
[EMBER_INSPECTOR]: <a href="https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi">https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi</a>
[EVENTS_BUBBLING]: <a href="http://emberjs.com/guides/understanding-ember/the-view-layer/#toc_event-bubbling">http://emberjs.com/guides/understanding-ember/the-view-layer/#toc_event-bubbling</a>
[FIXTURE_ADAPTER]: #creer-notre-modele-avec-le-fixtureadapter-de-ember-data
[GRUNT]: <a href="http://gruntjs.com">http://gruntjs.com</a>
[GRUNT_EMBER_HB]: <a href="https://gist.github.com/jkneb/6072299">https://gist.github.com/jkneb/6072299</a>
[GRUNT_EMBER_TPL]: <a href="https://gist.github.com/jkneb/6599001">https://gist.github.com/jkneb/6599001</a>
[INITIAL_ROUTES]: <a href="http://emberjs.com/guides/routing/defining-your-routes/#toc_initial-routes">http://emberjs.com/guides/routing/defining-your-routes/#toc_initial-routes</a>
[INPUT_HELPER]: <a href="http://emberjs.com/api/classes/Ember.Handlebars.helpers.html#method_input">http://emberjs.com/api/classes/Ember.Handlebars.helpers.html#method_input</a>
[JSON_CONVENTIONS]: <a href="http://emberjs.com/guides/models/the-rest-adapter/#toc_json-conventions">http://emberjs.com/guides/models/the-rest-adapter/#toc_json-conventions</a>
[LSAdapterGihub]: <a href="https://github.com/rpflorence/ember-localstorage-adapter">https://github.com/rpflorence/ember-localstorage-adapter</a>
[LSAdapter]: <a href="https://github.com/rpflorence/ember-localstorage-adapter/blob/master/localstorage_adapter.js">https://github.com/rpflorence/ember-localstorage-adapter/blob/master/localstorage_adapter.js</a>
[MOMENTJS]: <a href="http://momentjs.com">http://momentjs.com</a>
[ORIGINAL]: <a href="http://coding.smashingmagazine.com/2013/11/07/an-in-depth-introduction-to-ember-js/">http://coding.smashingmagazine.com/2013/11/07/an-in-depth-introduction-to-ember-js/</a>
[RENDER_HELPER]: <a href="http://emberjs.com/guides/templates/rendering-with-helpers/#toc_the-code-render-code-helper">http://emberjs.com/guides/templates/rendering-with-helpers/#toc_the-code-render-code-helper</a>
[ROUTES_GUIDES]: <a href="http://emberjs.com/guides/routing/defining-your-routes">http://emberjs.com/guides/routing/defining-your-routes</a>
[ROUTE_MODEL]: <a href="http://emberjs.com/guides/routing/specifying-a-routes-model">http://emberjs.com/guides/routing/specifying-a-routes-model</a>
[SPDECK_HW_ACCELERATION]: <a href="https://speakerdeck.com/ariya/fluid-user-interface-with-hardware-acceleration?slide=36">https://speakerdeck.com/ariya/fluid-user-interface-with-hardware-acceleration?slide=36</a>
[STACKOVERFLOW]: <a href="http://stackoverflow.com/questions/18593424/views-vs-components-in-ember-js">http://stackoverflow.com/questions/18593424/views-vs-components-in-ember-js</a>
[STYLED_DEMO]: <a href="http://jkneb.github.io/ember-crud">http://jkneb.github.io/ember-crud</a>
[TUTPLUS_EMBER]: <a href="http://net.tutsplus.com/tutorials/javascript-ajax/getting-into-ember-js-part-3">http://net.tutsplus.com/tutorials/javascript-ajax/getting-into-ember-js-part-3</a>
[TWITTER_BTN]: <a href="http://jsbin.com/OMOgUzo/1/edit?html,js,output">http://jsbin.com/OMOgUzo/1/edit?html,js,output</a>
[UNSTYLED_DEMO]: <a href="http://jkneb.github.io/ember-crud/unstyled">http://jkneb.github.io/ember-crud/unstyled</a>
[WEB_COMPONENTS]: <a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/index.html">https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/index.html</a></p>

<p>[EXT_BIG]: /images/ember/console-ember-extension1.png
[EXT_SMALL]: /images/ember/console-ember-extension1-300x156.png</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Angular en un jour, le guide ultime]]></title>
    <link href="http://vfsvp.fr/article/apprendre-angular-en-un-jour-le-guide-ultime"/>
    <updated>2013-11-02T00:00:00+01:00</updated>
    <id>http://vfsvp.fr/article/apprendre-angular-en-un-jour-le-guide-ultime</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://toddmotto.com/ultimate-guide-to-learning-angular-js-in-one-day/">Ultimate guide to learning AngularJS in one day par Todd Motto</a></p>

<h2>Qu'est-ce qu'AngularJS ?</h2>

<p>Angular est un framework MVC/MVVM côté client, développé en JavaScript, ce qui
est obligatoire pour faire une application moderne à page unique (ou même un
site internet). C'est un grand bond vers le futur de HTML et vers ce que HTML5
apporte. C'est également un grand bol d'air frais dans le monde des applications
web modernes. Cet article est une vue de bout en bout, issue de mon expérience,
et contient des conseils et astuces glanés au travers de mon utilisation
d'Angular.</p>

<!-- more -->


<h2>Terminologie</h2>

<p>Angular a une courbe d'apprentissage assez courte qui consiste principalement à
appréhender la terminologie et la &ldquo;pensée MVC&rdquo;. MVC signifie
Modèle-Vue-Contrôleur. Survolons un peu les différents composants et voyons un
peu la terminologie en jetant un oeil sur les APIs essentielles d'Angular.</p>

<h3>MVC</h3>

<p>Vous avez probablement déjà entendu parler de MVC. Utilisé dans de nombreux
langages de programmation pour apporter une structure/architecture à une
application. En voici les composants :</p>

<dl>
<dt>Modèle</dt>
<dd>   structure donnée représentant une entité de l'application, généralement
transmise en JSON. Pour bien démarrer avec Angular, quelques notions de JSON
sont nécessaires, cela vous permettra de faire communiquer votre serveur et vos
vues. Un groupe d'<em>id</em> d'utilisateurs pourrait par exemple ressembler à ceci :</dd>
</dl>

<pre><code class="json">{
  "users" : [{
    "name": "Joe Bloggs",
    "id": "82047392"
  },{
    "name": "John Doe",
    "id": "65198013"
  }]
}
</code></pre>

<p>Vous pouvez accéder à cette information de deux façons. En passant par une XHR
(XMLHttp Request), vous connaissez sûrement <code>$.ajax</code> en jQuery, Angular
l'encapsule dans <code>$http</code>. L'autre méthode est de l'écrire dans le code de la
page pour qu'elle soit chargée pendant l'interprétation (depuis un datastore ou
une base de données). Une fois que vous avez accès à l'information, vous pouvez
mettre à jour votre modèle et le renvoyer.</p>

<dl>
<dt>Vue</dt>
<dd>   La vue est simple, c'est votre HTML et/ou la sortie générée. Lorsque vous
utilisez un framework MVC, vous utilisez les données issues du Modèle pour
mettre votre Vue à jour et afficher les bonnes informations dans votre HTML.</dd>
<dt>Contrôleur</dt>
<dd>   Comme son nom l'indique, cette couche contrôle des choses. Mais quelles
choses ? Des données. Les contrôleurs permettent à votre serveur de communiquer
avec la Vue, c'est le messager, vous pouvez donc mettre vos données à jour à la
volée via ces canaux de communication entre le serveur et le client.</dd>
</dl>

<h3>Mettre en place un projet AngularJS (l'essentiel)</h3>

<p>Tout d'abord, nous devons mettre en place le minimum vital d'un projet Angular.
Nous devons mettre en place certaines choses avant de commencer. Cela revient,
en général, à ajouter une déclaration <code>ng-app</code>, écrire un contrôleur pour parler
à la vue puis l'inclusion d'Angular et un attachement au DOM. Voici
l'essentiel :</p>

<p>Un peu de HTML avec les déclarations <code>ng-*</code> :</p>

<p>``` html</p>

<div ng-app="myApp">
  <div ng-controller="MainCtrl">
    <!-- logique du contrôleur -->
  </div>
</div>


<pre><code>
Un module Angular et un contrôleur :
</code></pre>

<p>var myApp = angular.module(&lsquo;myApp&rsquo;, []);</p>

<p>myApp.controller(&lsquo;MainCtrl&rsquo;, [&lsquo;$scope&rsquo;, function ($scope) {
  // Magie du contrôleur
}]);
```</p>

<p>Avant de nous lancer, nous devons créer un module Angular dans lequel nous
allons placer toute notre logique. Il existe plusieurs manières de déclarer des
modules et vous pouvez chaîner toute votre logique (je n'aime pas cette
méthode) :</p>

<pre><code class="javascript">angular.module('myApp', [])
.controller('MainCtrl', ['$scope', function ($scope) {...}])
.controller('NavCtrl', ['$scope', function ($scope) {...}])
.controller('UserCtrl', ['$scope', function ($scope) {...}]);
</code></pre>

<p>La mise en place un module global s'est révélée être la meilleure pratique sur
les projets Angular sur lesquels j'ai travaillé. L'absence de point-virgules ou
les fermetures accidentelles de chaîne se sont montrées contre productives et
on souvent généré des erreurs de compilation. Préférez cette approche :</p>

<pre><code class="javascript">var myApp = angular.module('myApp', []);
myApp.controller('MainCtrl', ['$scope', function ($scope) {...}]);
myApp.controller('NavCtrl', ['$scope', function ($scope) {...}]);
myApp.controller('UserCtrl', ['$scope', function ($scope) {...}]);
</code></pre>

<p>Chaque nouveau fichier que je crée utilise le namespace <code>myApp</code> ce qui le
restreint à l'application. Oui, je crée un nouveau fichier pour chaque
Contrôleur, Directive, Factory ou tout autre élément (vous me remercierez plus
tard). Joignez les dans un fichier à la volée en utilisant Grunt ou un outil
similaire.</p>

<h3>Contrôleurs</h3>

<p>Maintenant que vous avez une idée de ce qu'est le MVC et que tout est en place,
jetons un oeil à la façon dont Angular implémente les contrôleurs.</p>

<p>Reprenons l'exemple vu plus haut et regardons pas à pas comment pousser des
données dans le DOM depuis un contrôleur. Angular utilise un système de template
qui ressemble à ceci pour parler à votre HTML : <code>{{ handlebars }}</code>. Idéalement, votre HTML ne contient aucun texte ou valeur en dur, cela
permet de tirer un maximum d'Angular. Voici un exemple dans lequel nous poussons
une chaîne de caractères dans le DOM :</p>

<p>
``` html</p>

<div ng-app="myApp">
  <div ng-controller="MainCtrl">
    {{ text }}
  </div>
</div>


<pre><code>
</code></pre>

<p>var myApp = angular.module(&lsquo;myApp&rsquo;, []);</p>

<p>myApp.controller(&lsquo;MainCtrl&rsquo;, [&lsquo;$scope&rsquo;, function ($scope) {</p>

<pre><code>$scope.text = 'Hello, Angular fanatic.';
</code></pre>

<p>}]);
```</p>

<p>Voici le Résultat :</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/toddmotto/mN7QB/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>Le concept clé ici est <code>$scope</code> que vous passez à toutes vos fonctions au sein
d'un contrôleur. <code>$scope</code> fait référence à l'élément courant (ou zone courante)
dans le DOM (ce qui est différent de <code>this</code>). Il encapsule intelligemment les
données et la logique pour que celles-ci soit limitées à l'élément. Cela apporte
un notion de publique/privé à JavaScript, ce qui est fantastique.</p>

<p>Le concept de <code>$scope</code> peut faire peur de prime abord mais c'est votre canal de
communication avec le DOM depuis le serveur (ou depuis les données statiques si
vous en avez). La démo donne une petite idée de comment &ldquo;pousser&rdquo; des données
dans le DOM.</p>

<p>Regardons maintenant une structure de données plus représentative que nous avons
hypothétiquement récupérée depuis le serveur pour afficher les détails de
l'utilisateur. À partir de maintenant, j'utiliserai des données statiques, je
vous montrerai plus tard comment récupérer dynamiquement des données JSON.</p>

<p>Commençons par un peu de JavaScript :</p>

<pre><code class="javascript">var myApp = angular.module('myApp', []);

myApp.controller('UserCtrl', ['$scope', function ($scope) {

    // Créons un namespace pour les détails de l'utilisateur
    // Également utile pour une aide visuelle dans le DOM
    $scope.user = {};
    $scope.user.details = {
      "username": "Todd Motto",
      "id": "89101112"
    };

}]);
</code></pre>

<p>Poussons ces données vers le DOM pour les afficher :</p>

<p>
``` html</p>

<div ng-app="myApp">
  <div ng-controller="UserCtrl">
    <p class="username">Welcome, {{ user.details.username }}</p>
    <p class="id">User ID: {{ user.details.id }}</p>
  </div>
</div>


<p>```
</p>

<p>Résultat:</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/toddmotto/425KU/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>Il est important de noter que les contrôleurs ont pour but de gérer les données
et de contenir des fonctions (ou événements) qui parlent au serveur pour
envoyer/recevoir des données JSON. Aucune manipulation du DOM ne doit y prendre
place, pas de jQuery ici donc. La manipulation du DOM se fait par les directives
que nous allons voir ensuite.</p>

<p>Astuce : dans la documentation d'Angular (au moment de la rédaction de cet
article) leur exemples créent un contrôleur comme ceci :</p>

<pre><code class="javascript">var myApp = angular.module('myApp', []);

function MainCtrl ($scope) {
  //...
};
</code></pre>

<p>&hellip; N'en faites rien. Cela expose toutes vos fonctions au contexte global et ne
les cantonne pas à votre application. Cela signifie également que vous ne pouvez
pas <em>minifier</em> votre code ou le tester facilement. Ne remplissez pas le
namespace global et gardez vos contrôleurs dans votre application.</p>

<h3>Directives</h3>

<p>Une directive (<a href="http://toddmotto.com/creating-an-angularjs-directive-from-one-of-your-existing-plugins-scripts">lisez mon article sur les directives issues de scripts/plugins
existants [en]</a>),
dans sa forme la plus simple, est un petit morceau de template HTML, utilisé de
préférence à plusieurs endroits de l'application. C'est un moyen facile
d'injecter sans effort du DOM dans votre application ou d'effectuer des
interactions particulières avec le DOM. Les directives ne sont pas simples pour
autant et la courbe d'apprentissage pour les maitriser est assez importante. Ce
qui suit devrait tout de même vous donner un bon point de départ.</p>

<p>À quoi servent donc les directives ? Beaucoup de choses dont la création de
composants DOM (onglets ou éléments de navigation) - tout dépend de l'usage que
votre application fait de l'interface utilisateur. Si vous avez, par exemple,
joué un peu avec <code>ng-show</code> ou <code>ng-hide</code>, ce sont des directives (qui n'injectent
pas de DOM).</p>

<p>Pour cet exercice, je vais faire simple et créer un type de bouton personnalisé
(appelé <code>customButton</code>) qui injecte quelques balises que je déteste devoir
écrire partout. Il y a plusieurs façons de définir une directive dans le DOM.
Voici quelques exemples :</p>

<p>``` html</p>

<!-- 1: déclaration en tant qu'attribut -->


<p><a custom-button>Click me</a></p>

<!-- 2: en tant que nouvel élément -->


<p><custom-button>Click me</custom-button></p>

<!-- 3: en tant que classe (pour être compatible avec les vieux IE) -->


<p><a class="custom-button">Click me</a></p>

<!-- 4: en tant que commentaire (peu adapté à cette démo) -->


<!-- directive: custom-button -->


<pre><code>
Je préfère les utiliser sous forme d'attribut. Les éléments personnalisés
feront partie de futures versions de HTML5 sous le nom de _Web Components_ mais
Angular les considère comme assez instables, en particulier pour les vieux
navigateurs.

Vous savez maintenant comment utiliser une directive, créons maintenant notre
bouton. Encore une fois, j'utilise le namespace `myApp`. Voici une directive
dans sa forme la plus simple :
</code></pre>

<p>myApp.directive(&lsquo;customButton&rsquo;, function () {
  return {
    link: function (scope, element, attrs) {
      // manipulation du DOM et événements
    }
  };
});
```</p>

<p>Je définis ma directive avec la méthode <code>.directive()</code> en lui passant le nom de
la directive <code>'customButton'</code>. Lorsque vous capitalisez une lettre dans le nom
d'une directive, il faut utiliser un tiret lorsque vous vous en servez (comme
dans l'exemple vu plus haut).</p>

<p>Une directive retourne une référence vers elle-même via un Object et accepte un
certain nombre de paramètres. Selon moi, les plus importants à connaitre sont
<code>restrict</code>, <code>replace</code>, <code>transclude</code>, <code>template</code>, <code>templateUrl</code> et, bien sûr, la
propriété <code>link</code>. Ajoutons les :</p>

<pre><code class="javascript">myApp.directive('customButton', function () {
  return {
    restrict: 'A',
    replace: true,
    transclude: true,
    template: '&lt;a href="" class="myawesomebutton" ng-transclude&gt;' +
                '&lt;i class="icon-ok-sign"&gt;&lt;/i&gt;' +
              '&lt;/a&gt;',
    link: function (scope, element, attrs) {
      // DOM manipulation/events here!
    }
  };
});
</code></pre>

<p>Résultat :</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/toddmotto/VC4H2/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>Utilisez <em>Inspecter l'Élément</em> pour vérifier que les balises ont bien été
injectées. Je sais, il n'y a pas d'icône parce que je n'ai pas inclus <em>Font
Awesome</em>, mais vous voyez le principe. En ce qui concerne les propriétés d'une
directive :</p>

<dl>
<dt>restrict</dt>
<dd>   Indique la méthode d'accès à l'élément. Si votre projet doit être
compatible avec d'anciennes versions d'IE, préférez une déclaration de type
attribut ou classe. Indiquer <code>'A'</code> signifie <em>attribut</em>, <code>'E'</code> signifie
<em>élément</em>, <code>'C'</code> signifie <em>classe</em> et <code>'M'</code> signifie <em>commentaire</em>. La valeur
par défaut est <code>'EA'</code>. Oui, il est tout à fait possible d'utiliser plusieurs
méthodes d'accès en même temps.</dd>
<dt>replace</dt>
<dd>   Indique si le balisage appelant la directive doit être remplacé ou non.
Dans l'exemple précédent, vous pouvez voir que le DOM initial est remplacé par
le template de la directive.</dd>
<dt>transclude</dt>
<dd>   Indique si le DOM original doit être copié dans la directive. Dans notre
exemple, le texte &lsquo;Click me&rsquo; apparait dans la directive lorsque celle-ci est
affichée.</dd>
<dt>template</dt>
<dd>   Un template, comme ci-dessus, permet de déclarer le balisage à injecter. Il
est préférable d'utiliser cette propriété pour de petits bouts de HTML
uniquement. Les templates injectés sont compilés par Angular, vous pouvez donc
utiliser des balises handlebars et les <em>bindings</em> dans ceux-ci.</dd>
<dt>templateUrl</dt>
<dd>   Similaire à <code>template</code>, permet de garder les templates dans leurs propres
fichiers ou au sein de balises <code>&lt;script&gt;</code>. Cette propriété permet d'indiquer
l'URL du template à utiliser. Pour des morceaux de HTML un peu plus complexes,
il est préférable de les placer chacun dans un fichier spécifique, dans un
dossier <em>templates</em> :</dd>
</dl>

<pre><code class="javascript">myApp.directive('customButton', function () {
  return {
    templateUrl: 'templates/customButton.html'
    // directive stuff...
  };
});
</code></pre>

<p>Et dans votre fichier (nom insensible à la casse) :</p>

<p>``` html</p>

<!-- dans customButton.html -->


<p><a href="" class="myawesomebutton" ng-transclude>
  <i class="icon-ok-sign"></i>
</a>
```</p>

<p>L'intérêt de cette technique est que le fichier HTML va être mis en cache par le
navigateur. Une alternative, qui n'est pas mise en cache, est de déclarer le
template dans une balise <code>&lt;script&gt;</code> :</p>

<p>``` html</p>

<script type="text/ng-template" id="customButton.html">
<a href="" class="myawesomebutton" ng-transclude>
  <i class="icon-ok-sign"></i>
</a>
</script>


<pre><code>
Cela indique à Angular que c'est un `ng-template` et lui donne un ID. Angular va
chercher le _ng-template_ ou le fichier _*.hml_. Je préfère utiliser des
fichiers _*.html_, ils sont plus faciles à gérer, augmentent les performances et
gardent le DOM propre. Si vous avez une centaine de directives, ce sera plus
simple pour les parcourir.

### Services

Les services sont souvent une notion un peu floue. D'après mes lectures et ma
propre expérience, les services sont plus un design pattern de style qu'un réel
apport de fonctionnalité. J'ai lu le code source d'Angular et à priori ils sont
très proches des factories. Ils passent par le même compilateur et semble avoir
de nombreuses fonctionnalités en commun. Il semble que les services soient
préférables pour _singleton_ et les factories pour les fonctions plus complexes
comme les _Object Literals_ ou d'autres cas plus compliqués.

Voici un exemple de service qui multiplie deux nombres :
</code></pre>

<p>myApp.service(&lsquo;Math&rsquo;, function () {
  this.multiply = function (x, y) {
    return x * y;
  };
});
```</p>

<p>Il s'utilise ensuite comme ceci dans un contrôleur :</p>

<pre><code class="javascript">myApp.controller('MainCtrl', ['$scope', function ($scope) {
    var a = 12;
    var b = 24;

    // outputs 288
    var result = Math.multiply(a, b);
}]);
</code></pre>

<p>Je sais, une multiplication ne nécessite pas un service en soi mais vous voyez
où je veux en venir.</p>

<p>Lorsque l'on crée un service (ou une factory) il faut utiliser l'injection de
dépendance pour indiquer à Angular de le prendre en charge. Sans cela, on aura
une erreur de compilation et notre contrôleur plantera. Vous avez sans doute
remarqué la partie <code>function ($scope)</code> du contrôleur, c'est une simple
injection de dépendance, c'est ici que le code doit être placé. Vous aurez
remarqué également le <code>['$scope']</code> placé avant, j'y reviendrai plus tard. Voici
comment utiliser une injection de dépendance pour dire à Angular que vous voulez
utiliser un service :</p>

<pre><code class="javascript">// Passez Math
myApp.controller('MainCtrl', ['$scope', 'Math', function ($scope, Math) {
    var a = 12;
    var b = 24;

    // outputs 288
    var result = Math.multiply(a, b);
}]);
</code></pre>

<h3>Factories</h3>

<p>Passer des services aux factories devrait être assez simple, on pourrait créer
un <em>Object Literal</em> dans une factory ou simplement fournir des méthodes plus
avancées :</p>

<pre><code class="javascript">myApp.factory('Server', function () {
  return {
    get: function(url) {
      return $http.get(url);
    },
    post: function(url) {
      return $http.post(url);
    },
  };
});
</code></pre>

<p>Je crée ici un wrapper personnalisé pour l'objet XHR de Angular. Après injection
de dépendance dans le contrôleur, l'utilisation est aisée :</p>

<pre><code class="javascript">myApp.controller('MainCtrl', ['$scope', 'Server', function ($scope, Server) {
    var jsonGet = 'http://myserver/getURL';
    var jsonPost = 'http://myserver/postURL';
    Server.get(jsonGet);
    Server.post(jsonPost);
}]);
</code></pre>

<p>Si vous vouliez surveiller des changements côté serveur, vous pourriez mettre
en place <code>Server.poll(jsonPoll)</code> ou, si vous utilisez par exemple un socket,
vous pourriez mettre en place <code>Server.socket(jsonSocket)</code>. Ce mécanisme permet
de modulariser le code et de créer des outils réutilisables tout en gardant le
code des contrôleur à son minimum.</p>

<h3>Filtres</h3>

<p>Les filtres sont utiles avec les tableaux de données mais également en dehors
des boucles. Si vous parcourez une collection de données et que vous souhaitez
les filtrer, vous êtes au bon endroit. Les filtres peuvent également s'utiliser
pour filtrer la saisie d'un utilisateur dans un champ <code>&lt;input&gt;</code> par exemple. Les
filtres s'utilisent de deux façons : dans un contrôleur ou sous forme de
méthode. Voici la version en méthode, qui peut s'utiliser partout :</p>

<pre><code class="javascript">myApp.filter('reverse', function () {
  return function (input, uppercase) {
    var out = '';
    for (var i = 0; i &lt; input.length; i++) {
      out = input.charAt(i) + out;
    }
    if (uppercase) {
      out = out.toUpperCase();
    }
    return out;
  }
});

// Contrôleur inclus pour fournir des données
myApp.controller('MainCtrl', ['$scope', function ($scope) {
    $scope.greeting = 'Todd Motto';
}]);
</code></pre>

<p>DOM usage:</p>

<p>
``` html</p>

<div ng-app="myApp">
  <div ng-controller="MainCtrl">
    <p>Sans filtre: {{ greeting }}</p>
    <p>Reverse: {{ greeting | reverse }}</p>
  </div>
</div>


<p>```
</p>

<p>Résultat :</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/toddmotto/pmh4s/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>Et voici comment l'utiliser dans un <code>ng-repeat</code> :</p>

<p>
``` html</p>

<ul>
  <li ng-repeat="number in myNumbers |filter:oddNumbers">{{ number }}</li>
</ul>


<pre><code>

Voici également un cas d'utilisation réel de filtres dans un contrôleur :
</code></pre>

<p>myApp.controller(&lsquo;MainCtrl&rsquo;, [&lsquo;$scope&rsquo;, function ($scope) {</p>

<p>  $scope.numbers = [10, 25, 35, 45, 60, 80, 100];</p>

<p>  $scope.lowerBound = 42;</p>

<p>  // Does the Filters
  $scope.greaterThanNum = function (item) {
      return item > $scope.lowerBound;
  };</p>

<p>}]);
```</p>

<p>Et son utilisation dans <code>ng-repeat</code> :</p>

<p>
<code>html
&lt;li ng-repeat="number in numbers | filter:greaterThanNum"&gt;
  {{ number }}
&lt;/li&gt;
</code>
</p>

<p>Résultat :</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/toddmotto/cZbCf/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>Voilà notre tour des briques majeures d'Angular terminé. Ce n'est que le tout
début de notre plongée en eaux profondes, mais c'est amplement suffisant pour
vous permettre de créer votre première application Angular.</p>

<h2>Binding de données à deux sens</h2>

<p>La première fois que j'ai entendu parler de <em>binding</em> de données à deux sens, je
n'étais pas sûr de bien comprendre. La meilleure façon de le décrire est sous la
forme d'un cercle de données synchronisées : si le modèle est mis à jour, la vue
est mise à jour automatiquement ; si la vue est mise à jour, le modèle est
automatiquement mis à jour. Cela veut dire que sans rien faire, la donnée est
synchronisée. Si je <em>bind</em> un <code>ng-model</code> à un <code>&lt;input&gt;</code> et commence à taper dans
ce dernier, cela crée un modèle (ou met à jour un modèle existant) en même
temps.</p>

<p>Je crée ici le <code>&lt;input&gt;</code> et lui <em>bind</em> un modèle <code>myModel</code>, je peux ensuite
utiliser les accolades pour afficher la donnée de mon modèle (ainsi que ses
mises à jour) dans la vue :</p>

<p>
``` html</p>

<div ng-app="myApp">
  <div ng-controller="MainCtrl">
    <input type="text" ng-model="myModel" placeholder="Start typing..." />
    <p>My model data: {{ myModel }}</p>
  </div>
</div>


<pre><code>
</code></pre>

<p>myApp.controller(&lsquo;MainCtrl&rsquo;, [&lsquo;$scope&rsquo;, function ($scope) {
  // On capture la donnée du modèle
  // et/ou on l'initialise avec une chaîne de caractères vide
  $scope.myModel = &lsquo;&rsquo;;
}]);
```</p>

<p>Résultat :</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/toddmotto/qrr3q/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h2>Appels XHR/Ajax/$http et binding JSON</h2>

<p>Vous savez maintenant comment envoyer des données à <code>$scope</code> et comment
fonctionne le <em>binding</em> de données dans les modèles. Il est donc maintenant
temps de simuler quelques XHR vers le serveur. Ce n'est pas essentiel pour un
site web classique, à moins d'avoir des besoins Ajax spécifiques, c'est donc
plus orienté vers la récupération de données pour une application web.</p>

<p>En développement local, vous utilisez probablement Java, ASP .NET, PHP ou une
autre techno pour faire tourner l'application. Que vous contactiez une bonne de
données locale ou que vous utilisiez ce serveur comme une API pour communiquer
avec une autre ressource, la mise en place est globalement la même.</p>

<p>C'est ici que &lsquo;dollar http&rsquo; entre en scène. C'est dorénavant votre meilleur ami.
La méthode <code>$http</code> d'Angular est un <em>wrapper</em> bien pratique pour accéder aux
données du serveur et est d'une utilisation très simple. Voici un petit exemple
pour une requête <em>GET</em> qui, comme vous l'aurez deviné, récupère des données
depuis le serveur. Sa syntaxe est très proche de celle de jQuery, la transition
est donc aisée :</p>

<pre><code class="javascript">myApp.controller('MainCtrl', ['$scope', function ($scope) {
  $http({
    method: 'GET',
    url: '//localhost:9000/someUrl'
  });
}]);
</code></pre>

<p>Angular vous retourne ce qu'on appelle une <em>promise</em> ce qui est une façon très
efficace et lisible de gérer les <em>callbacks</em>. Les <em>promises</em> sont rattachées à
la fonction qui les as créées via la notation <code>.myPromise()</code>. Tout
naturellement, nous avons la main sur <code>success</code> et <code>error</code> :</p>

<pre><code class="javascript">myApp.controller('MainCtrl', ['$scope', function ($scope) {
  $http({
    method: 'GET',
    url: '//localhost:9000/someUrl'
  })
  .success(function (data, status, headers, config) {
    // données récupérées avec succès
  })
  .error(function (data, status, headers, config) {
    // erreur de récupération :(
  });
}]);
</code></pre>

<p>Tout à fait lisible. C'est ici que nous fusionnons la vue et le serveur en
y attachant un modèle ou en mettant le modèle à jour dans le DOM. Disons que
tout est déjà mis en place et affichons un nom d'utilisateur dans le DOM à
partir d'un appel Ajax.</p>

<p>En théorie, nous devrions concevoir notre JSON en premier, ce qui affecte la
façon dont on l'attache à nos données. Faisons simple, voici ce que le serveur
nous fournit :</p>

<pre><code class="json">{
  "user": {
    "name": "Todd Motto",
    "id": "80138731"
  }
}
</code></pre>

<p>Nous allons recevoir un <em>Object</em> (que nous appellerons <em>data</em>, on peut voir que
<em>data</em> est passé à notre handler) et devons interagir avec la propriété
<code>data.user</code>. Dans <code>data.user</code>, nous trouvons <code>name</code> et <code>id</code>. Obtenir leur valeur
est assez simple, il nous suffit par exemple de faire appel à <code>data.user.name</code>
ce qui nous donne &lsquo;Todd Motto&rsquo;.</p>

<p>Le code JavaScript :</p>

<pre><code class="javascript">myApp.controller('UserCtrl', ['$scope', function ($scope) {

  // Crée un Object user
  $scope.user = {};

  // Initialise le modèle avec une chaîne vide
  $scope.user.username = '';

  // Nous voulons effectuer la requête
  // et obtenir le nom de l'utilisateur
  $http({
    method: 'GET',
    url: '//localhost:9000/someUrlForGettingUsername'
  })
  .success(function (data, status, headers, config) {
    // Ici nous assignons cet utilisateur à
    // notre modèle existant !
    $scope.user.username = data.user.name;
  })
  .error(function (data, status, headers, config) {
    // Une erreur est survenue
  });
}]);
</code></pre>

<p>Il nous suffit maintenant de faire ceci dans le DOM :</p>

<p>
``` html</p>

<div ng-controller="UserCtrl">
  <p>{{ user.username }}</p>
</div>


<pre><code>

Ceci va afficher le nom de l'utilisateur. Nous allons faire un pas de plus et
comprendre le _data-binding_ déclaratif et c'est là que ça devient vraiment
intéressant.

## Data-binding déclaratif

La philosophie d'Angular est de créer du HTML dynamique, riche en
fonctionnalités et d'effectuer, de façon transparente, beaucoup de choses dont
on n'oserait à peine rêver côté web client. Et c'est exactement ce qu'ils ont
fait.

Imaginons que nous venons de faire une requête Ajax pour récupérer une liste
d'emails avec leur sujet ainsi que leur date d'envoi et souhaitons les afficher
dans le DOM. C'est là qu'Angular montre toute sa force. Nous allons tout
d'abord devoir écrire un contrôleur d'emails :
</code></pre>

<p>myApp.controller(&lsquo;EmailsCtrl&rsquo;, [&lsquo;$scope&rsquo;, function ($scope) {</p>

<p>  // Crée un Object emails
  $scope.emails = {};</p>

<p>  // Nous écrivons ici en dur les données normalement
  // reçues du serveur
  $scope.emails.messages = [{
        &ldquo;from&rdquo;: &ldquo;Steve Jobs&rdquo;,
        &ldquo;subject&rdquo;: &ldquo;I think I&rsquo;m holding my phone wrong :/&rdquo;,
        &ldquo;sent&rdquo;: &ldquo;2013-10-01T08:05:59Z&rdquo;
    },{
        &ldquo;from&rdquo;: &ldquo;Ellie Goulding&rdquo;,
        &ldquo;subject&rdquo;: &ldquo;I&rsquo;ve got Starry Eyes, lulz&rdquo;,
        &ldquo;sent&rdquo;: &ldquo;2013-09-21T19:45:00Z&rdquo;
    },{
        &ldquo;from&rdquo;: &ldquo;Michael Stipe&rdquo;,
        &ldquo;subject&rdquo;: &ldquo;Everybody hurts, sometimes.&rdquo;,
        &ldquo;sent&rdquo;: &ldquo;2013-09-12T11:38:30Z&rdquo;
    },{
        &ldquo;from&rdquo;: &ldquo;Jeremy Clarkson&rdquo;,
        &ldquo;subject&rdquo;: &ldquo;Think I&rsquo;ve found the best car&hellip; In the world&rdquo;,
        &ldquo;sent&rdquo;: &ldquo;2013-09-03T13:15:11Z&rdquo;
    }];</p>

<p>}]);
<code>``
Nous devons maintenant faire le lien avec notre HTML. C'est là que nous allons
utiliser le _binding_ déclaratif pour indiquer ce que va faire l'application -
créer notre premier morceau de HTML dynamique. Nous allons utiliser la
directive</code>ng-repeat` d'Angular qui va parcourir les données et générer un
résultat sans que nous ayant à faire de <em>callbacks</em> ou de changements d'état,
c'est gratuit :</p>

<p>
``` html</p>

<ul>
  <li ng-repeat="message in emails.messages">
    <p>From: {{ message.from }}</p>
    <p>Subject: {{ message.subject }}</p>
    <p>{{ message.sent | date:'MMM d, y h:mm:ss a' }}</p>
  </li>
</ul>


<p>```
</p>

<p>Résultat :</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/toddmotto/TAVQc/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>J'ai également ajouté un <em>filtre</em> pour vous montrer comment afficher
correctement une date UTC.</p>

<p>Documentez vous sur les directives <code>ng-*</code> d'Angular, cela vous permettra
d'exploiter pleinement le <em>binding</em> de directives, cela vous montre comment
faire le lien entre les données du serveur, la couche modèle et la vue et
comment afficher les données.</p>

<h2>Les fonctions de <em>scope</em></h2>

<p>Après le <em>binding</em> de directives, les fonctions de <em>scope</em> sont la suite logique
dans la création d'une application. Voici une fonction assez simple nous
permettant de supprimer un email dans notre collection :</p>

<pre><code class="javascript">myApp.controller('MainCtrl', ['$scope', function ($scope) {

  $scope.deleteEmail = function (index) {
    $scope.emails.messages.splice(index, 1)
  };

}]);
</code></pre>

<p>Astuce: Il est important de penser en termes de suppression au niveau du modèle.
Vous ne touchez à rien de ce qui concerne le DOM, Angular est un framework MVC
et se charge de tout grâce à son binding de données à deux sens et à son
fonctionnement sans callbacks, il vous suffit d'organiser votre code de façon
à ce qu'il réponde à vos données !</p>

<p>L'attachement des fonctions au scope se fait également par le biais des
directives <code>ng-*</code>, dans le cas suivant, il s'agit de <code>ng-click</code> :</p>

<pre><code class="html">&lt;a ng-click="deleteEmail($index)"&gt;Delete email&lt;/a&gt;
</code></pre>

<p>Ceci est très différent d'un événement <em>click</em> inline et ce pour plusieurs
raisons dont je vous parlerai bientôt. Comme vous pouvez le voir, je passe
<code>$index</code> en paramètre. Angular sait quel élément vous êtes en train de
supprimer :</p>

<p>Résulat (supprimez quelques emails !) :</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/toddmotto/BgZmt/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h2>Méthodes de DOM déclaratives</h2>

<p>Nous allons maintenant voir les méthodes de DOM. Elles sont commes les
directives et permettent d'ajouter au DOM des fonctionnalités pour lesquelles
vous auriez, en temps normal, beaucoup de code à écrire. Un très bon exemple
serait une navigation déroulante. En utilisant <code>ng-show</code> et <code>ng-click</code> nous
pouvons mettre cela en place très simplement :</p>

<p>``` html
<a href="" ng-click="toggle = !toggle">Afficher menu</a></p>

<ul ng-show="toggle">
  <li>Lien 1</li>
  <li>Lien 2</li>
  <li>Lien 3</li>
</ul>


<p>```</p>

<p>C'est ici que MVVM entre en jeu. Comme vous pouvez le voir, il n'y a pas de
contrôleur à écrire. Nous reviendrons bientôt sur MVVM.</p>

<p>Résultat (vous pouvez dérouler le menu) :</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/toddmotto/ZUyW5/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h2>Les expressions</h2>

<p>C'est une des choses que je préfère dans Angular, ce pour quoi on utilise
habituellement JavaScript en écrivant beaucoup de code répétitif.</p>

<p>Avez-vous déjà fait ceci ?</p>

<pre><code class="javascript">elem.onclick = function (data) {
  if (data.length === 0) {
    otherElem.innerHTML = 'No data';
  } else {
    otherElem.innerHTML = 'My data';
  }
};
</code></pre>

<p>Ce pourrait par exemple être le callback d'une requête <em>GET</em> dans lequel vous
modifiez le DOM en fonction de l'état des données. Angular vous permet de faire
la même chose sans écrire une ligne de JavaScript !</p>

<p>
``` html</p>

<p>{{ data.length > 0 && 'My data' || 'No data' }}</p>


<p>```
</p>

<p>Ce morceau de DOM va être automatiquement mis à jour, sans besoin de callback,
au fur et à mesure que votre application récupère les données. Il vous indiquera
si des données sont présentes ou non. Il y a une de très nombreux cas d'usage et
Angular le gère automatiquement grâce au binding de données à deux sens.</p>

<p>Résultat :</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/toddmotto/XCwcr/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h2>Routage et vues dynamiques</h2>

<p>La philosophie des applications côté client (et des applications web en
général) est assez simple : Vous avez un header, un footer, une sidebar et le
contenu au milieu injecte du contenu par magie en fonction de l'URL.</p>

<p>Angular facilite beaucoup la mise en place d'un tel mécanisme, ce qu'on
appellerait les vues dynamiques. Les vues sont injectées dynamiquement au
travers de <code>$routeProvider</code>, en fonction de l'URL.</p>

<pre><code class="javascript">myApp.config(['$routeProvider', function ($routeProvider) {

  /**
   * $routeProvider
   */
  $routeProvider
  .when('/', {
    templateUrl: 'views/main.html'
  })
  .otherwise({
    redirectTo: '/'
  });

}]);
</code></pre>

<p>Lorsque vous êtes sur l'URL <code>/</code> (la page d'accueil du site), le template utilisé
est <code>main.html</code>. Vous devez appeler votre vue initiale <code>main.html</code> puisque vous
avez déjà un fichier <code>index.html</code> contenant votre site en page unique. Il est
très simple d'ajouter des vues supplémentaires en fonction de l'URL :</p>

<pre><code class="javascript">myApp.config(['$routeProvider', function ($routeProvider) {

  /**
   * $routeProvider
   */
  $routeProvider
  .when('/', {
    templateUrl: 'views/main.html'
  })
  .when('/emails', {
    templateUrl: 'views/emails.html'
  })
  .otherwise({
    redirectTo: '/'
  });

}]);
</code></pre>

<p>Nous pouvons par exemple charger le HTML de notre liste d'emails quand on visite
l'URL <code>emails.html</code>. Vous pouvez créer une application sophistiquée avec assez
peu d'efforts.</p>

<p><code>$routeProvider</code> propose d'autres fonctionnalités qui valent la peine de
fouiller un peu, mais avec ceci vous avez déjà de quoi faire des choses
intéressantes. Il y a, par exemple, les intercepteurs <code>$http</code> qui émettent des
événements lorsqu'une requête Ajax est en cours, ce qui permettrait d'afficher
un spinner pendant que les données sont récupérées.</p>

<h2>Données statiques globales</h2>

<p>Gmail récupère une bonne partie de ses données en les écrivant en JSON dans la
page (inspectez les sources de la page). Si vous voulez accéder instantanément à
vos données dès le chargement de l'application et accélérer son lancement, cette
technique est très pratique.</p>

<p>Lorsque je développe nos applications, des balises issues de Java sont insérez
dans le DOM et, une fois l'application chargée, les données viennent du serveur.
Je parle ici de Java mais vous pouvez utiliser n'importe quel langage côté
serveur. Voici comment ajouter le JSON dans votre page et comment le charger
ensuite depuis un contrôleur :</p>

<p>``` html</p>

<!-- dans index.html (en bas de page) -->


<script>
window.globalData = {};
globalData.emails = <baliseJavaPourGenererLesMessages>;
</script>


<pre><code>
Ma balise Java va être remplacée par les bonnes données au moment de l'affichage
et Angular va affiche instantanément les emails. Récupérez simplement les
données dans un contrôleur :
</code></pre>

<p>myApp.controller(&lsquo;EmailsCtrl&rsquo;, [&lsquo;$scope&rsquo;, function ($scope) {</p>

<pre><code>$scope.emails = {};

// Assigner les données initiales !
$scope.emails.messages = globalData.emails;
</code></pre>

<p>}]);
```</p>

<h2>Minification (réduction du code)</h2>

<p>Je vais parler rapidement de minification avec le code Angular. Vous avez
probablement joué un peu avec Angular et avez peut-être utilisé un
<em>minifier</em>&hellip; et eu une erreur !</p>

<p>Minifier le code AngularJS est simple, vous devez simplement spécifier les
injections de dépendances dans un tableau, avant la fonction :</p>

<pre><code class="javascript">myApp.controller('MainCtrl',
['$scope', 'Dependency', 'Service', 'Factory',
function ($scope, Dependency, Service, Factory) {

  // code

}]);
</code></pre>

<p>Une fois minifié :</p>

<pre><code class="javascript">myApp.controller('MainCtrl',
['$scope', 'Dependency', 'Service', 'Factory',
function (a,b,c,d) {

  // a = $scope
  // b = Dependency
  // c = Service
  // d = Factory

  // $scope alias usage
  a.someFunction = function () {...};

}]);
</code></pre>

<p>Rappelez-vous bien de garder la liste des injections dans le même ordre que les
paramètres de la fonction, vous risqueriez un bon mal de crâne dans le cas
contraire.</p>

<h2>Différences avec MVC et MVVM</h2>

<p>Nous arrivons à la fin de ce long article sur AngularJS. Je vais cependant faire
une passe rapide sur les différences avec MVC/MVVM dont AngularJS est fier :</p>

<ul>
<li><em>MVC</em>: parle avec un contrôleur, Modèle-Vue-Contrôleur</li>
<li><em>MVVM</em>: encapsule une <em>binding</em> de données décalaratif qui, téchniquement, se
parle à lui-même. Modèle-Vue-Vue-Modèle. Le modèle parle à la vue et la vue
peut parler au modèle. Le binding de données à deux sens d'Angular permet de
garder cette synchronisation sans rian avoir à écrire. Cela vous permet
d'écrire de la logique sans contrôleur.</li>
</ul>


<p>Un exemple rapide, vous pouvez utiliser <code>ng-repeat</code> sans contrôleur en
fournissant directement les données :</p>

<p>
<code>html
&lt;li ng-repeat="number in [1,2,3,4,5,6,7,8,9]"&gt;
  {{ number }}
&lt;/li&gt;
</code>
</p>

<p>Pour un test rapide c'est acceptable mais je vous conseille de toujours avoir
un contrôleur lorsque vous développez.</p>

<p>Résultat :</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/toddmotto/C9GHF/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h2>HTML5 Web Components</h2>

<p>Comme nous l'avons vu plus haut, AngularJS permet de créer des éléments
personnalisés :</p>

<pre><code class="html">&lt;myCustomElement&gt;&lt;/myCustomElement&gt;
</code></pre>

<p>Cela permet d'aligner le web avec le futur de HTML5 qui introduit les <em>web
components</em> et l'élément <code>&lt;template&gt;</code>. Angular nous permet de les utiliser dès
aujourd'hui. Les <em>web components</em> mélangent éléments personnalisés et injection
dynamique de JavaScript pour peupler dynamiquement la vue, c'est très excitant
et déjà possible avec Angular ! Ils ont un cran d'avance et permettent de
s'assurer que ce qui arrive fonctionne - chapeau bas.</p>

<h2>Commentaires de scope</h2>

<p>Les commentaires de scopes sont, selon moi, utiles dans mon workflow. Plutôt que
d'ajouter des commentaires comme ceci dans mon HTML :</p>

<p>``` html</p>

<!-- header -->


<p><header>
  Stuff.
</header></p>

<!-- /header -->


<pre><code>
Lorsque l'on parle d'Angular, il faut penser en termes de vues et de scopes, pas
de DOM ! Les scopes sont cloisonnés, ce qui signifie que, à moins de partager
délibérément les données entre les contrôleurs, vos données sont encapsulées et
inaccessibles de l'extérieur. Je trouve que noter les régions cloisonnées aide
beaucoup :
</code></pre>

<!-- scope: MainCtrl -->


<div class="content" ng-controller="MainCtrl">

</div>


<!-- /scope: MainCtrl -->


<p>```</p>

<h2>Debugger AngularJS</h2>

<p>Il y a une extension Chrome géniale que les gens de Google recommandent pour
développer et debugger avec Angular, il s'agit de Batarang et vous pouvez la
récupérer <a href="https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk">ici</a>.</p>

<p>Happy coding.</p>

<h2>À lire également</h2>

<p>Apprenez comment <a href="http://toddmotto.com/creating-an-angularjs-directive-from-one-of-your-existing-plugins-scripts">créer votre propre directive</a> depuis un script ou un plugin.</p>
]]></content>
  </entry>
  
</feed>
