<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: elixir | VF svp]]></title>
  <link href="http://vfsvp.fr/tags/elixir/atom.xml" rel="self"/>
  <link href="http://vfsvp.fr/"/>
  <updated>2014-07-30T12:13:02+02:00</updated>
  <id>http://vfsvp.fr/</id>
  <author>
    <name><![CDATA[Simon Courtois (@simonc)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir pour les rubyists (partie 2)]]></title>
    <link href="http://vfsvp.fr/article/elixir-pour-les-rubyists-2"/>
    <updated>2013-10-29T21:00:00+01:00</updated>
    <id>http://vfsvp.fr/article/elixir-pour-les-rubyists-2</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.natescottwest.com/blog/2013/10/09/elixir-for-rubyists-part-2/">Elixir for Rubyists part 2 par Nate West</a></p>

<p>Voici une tentative de réponse aux questions de la <a href="/article/elixir-pour-les-rubyists-1">partie 1</a>.</p>

<h2>Immuable ??</h2>

<p>Les variables d'Elixir sont immuables. Elles ne sont pas à assignation unique.
Je vous entends déjà dire &ldquo;Mais Nate ! Si on réassigne une variable, n'est-ce
pas une mutation ?&rdquo;. Non !</p>

<h2>Elixir assure la transparence référentielle des variables</h2>

<p>Transparence référentielle est une façon académique de dire &ldquo;quand je fais
quelque chose qui modifie une valeur, je peux toujours revenir à la valeur
originale&rdquo;. Jessica Kerr (<a href="https://twitter.com/jessitron">@jessitron</a>) appelle
cela &ldquo;données en entrée, données en sortie&rdquo; (<em>data in, data out</em>). Sous forme
de code :</p>

<!-- more -->


<pre><code class="elixir">name = "Nate"
# =&gt; "Nate"
String.upcase(name)
# =&gt; "NATE"
name
# =&gt; "Nate"
</code></pre>

<p><code>String.upcase</code> est référentiellement transparent. Il retourne une nouvelle
valeur transformée mais ne modifie pas la valeur originale. On peut comparer
cela avec <code>String#upcase!</code> en Ruby.</p>

<pre><code class="ruby">name = "Nate"
# =&gt; "Nate"
name.upcase!
# =&gt; "NATE"
name
# =&gt; "NATE"
</code></pre>

<p><code>String#upcase!</code> <em>n'est pas</em> référentiellement transparent. Non seulement il
retourne une valeur transformée mais modifie également la valeur originale.</p>

<p>Avec Elixir, dans le contexte d'une fonction vous ne pourrez pas modifier la
valeur d'une variable.</p>

<pre><code class="elixir">name = "Nate"
# =&gt; "Nate"
capitalize = fn(string) -&gt; string = String.upcase(string) end
# =&gt; #Function&lt;6.80484245 in :erl_eval.expr/5&gt;
capitalize.(name)
# =&gt; "NATE"
name
# =&gt; "Nate"
</code></pre>

<h2>En quoi la transparence référentielle est importante ?</h2>

<p>Pour faire court, un code référentiellement transparent est simple à tester,
facile à comprendre et à rendre <em>threadsafe</em>. Si on a ceci en Ruby :</p>

<pre><code class="elixir">greeting = "Hello"
do_something_to_string(greeting)
print(greeting)
</code></pre>

<p>On s'attend à ce que <code>greeting</code> ait la valeur &ldquo;Hello&rdquo; lorsque l'on appelle
<code>print</code> mais <code>do_something_to_string</code> a pu modifier la valeur de <code>greeting</code>.
D'autant plus si <code>greeting</code> est transmis un peu partout dans l'application et
passe par toutes sortes de <code>do_somethings</code>. Au moment d'afficher <code>greeting</code>, il
pourrait tout aussi bien contenir &ldquo;Game over !&rdquo;.</p>

<p>Pour en savoir plus :</p>

<ul>
<li><a href="http://confreaks.com/videos/2382-rmw2013-functional-principles-for-oo-development">Jessica Kerr’s Functional Principles (en)</a></li>
<li><a href="http://rubyrogues.com/115-rr-functional-and-object-oriented-programming-with-jessica-kerr/">Ruby Rogues Podcast: Functional and OO Programming (en)</a></li>
<li>Si vous pensez à d'autres ressources, dites le moi, je les ajouterai.</li>
</ul>


<h2>Un piège&hellip;</h2>

<p>Il est possible d'assigner une nouvelle valeur à une variable en se basant sur
sa valeur actuelle. Notez bien qu'ici <code>=</code> n'est pas un opérateur d'assignation.
C'est un opérateur de test de correspondance. Lorsque l'on utilise sur une
variable, on peut choisir de tester la valeur de la variable ou nous pouvons
l'autoriser à prendre une nouvelle valeur.</p>

<pre><code class="elixir">1 = 2 # la valeur 1 ne correspond pas à la valeur 2
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3

:a = 2 # la valeur :a, un atôme (un peu comme un symbole en Ruby),
       # ne correspond pas à la valeur 2
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3

num = 2 # num est une variable. Nous pouvons lui assigner 2 pour établir
        # une correspondance.
# =&gt; 2

^num = 3 # la valeur de num (2) ne correspond pas à la valeur 3
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3

num = 3 # ici on ne cherche pas de correspondance, on peut donc assigner la
        # valeur 3 à num
# =&gt; 3
</code></pre>

<p>Tel que je le comprends, cela fait parti d'Elixir pour des questions pratique
et est particulièrement utile pour écrire des macros. Les puristes de la
programmation fonctionnelle vont détester ça. Si c'est votre cas, vous pouvez
lire <a href="https://groups.google.com/forum/#!searchin/elixir-lang-core/single$20assignment/elixir-lang-core/FrK7MQGuqWc/2aimbHDAAHMJ">cette discussion</a>
au sujet de la réassignation de variables dans Elixir et jeter un oeil au
commentaire de Joe Armstrong.</p>

<p>Encore une fois, cela ne change pas l'état de l'objet. Il n'y a pas d'objet dans
Elixir. <code>num</code> est un simple conteneur de données auquel vous pouvez donner une
nouvelle valeur. Lorsque vous le faites, l'ancienne valeur va être retirée du
contexte d'exécution afin de laisser la place libre pour stocker une nouvelle
valeur.</p>

<h2>Essayez donc de le briser</h2>

<p>Vous aurez tout de même beaucoup de mal à écrire une fonction qui brise la
transparence référentielle. Si vous réassignez une variable dans une fonction,
vous ne changez sa valeur que pour le contexte de cette fonction.</p>

<pre><code class="elixir">defmodule Assignment do
  def change_me(string) do
    string = 2
  end
end

# lorsque vous compilez ce module, vous aurez un warning indiquant
# qu'une variable de type string n'est pas utilisée!

greeting = "Hi"
# =&gt; "Hi"
Assignment.change_me(greeting)
# =&gt; 2
greeting
# =&gt; "Hi"
</code></pre>

<h2>C'est tout pour aujourd'hui</h2>

<p>Voici la fin de la partie 2. À bientôt pour la partie 3.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir pour les rubyists (partie 1)]]></title>
    <link href="http://vfsvp.fr/article/elixir-pour-les-rubyists-1"/>
    <updated>2013-10-27T18:30:00+01:00</updated>
    <id>http://vfsvp.fr/article/elixir-pour-les-rubyists-1</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.natescottwest.com/blog/2013/09/26/elixir-for-rubyists/">Elixir for Rubyists part 1 par Nate West</a></p>

<p>Elixir est mon nouveau langage préféré. Cet article est le premier d'une série
de longueur indéterminée sur Elixir. En tant que rubyist, la syntaxe d'Elixir va
vous sembler familière. Je vais donc vous montrer beaucoup de code pour
vous expliquer comment il marche. Elixir est fonctionnel et amusant
(FUNctional).</p>

<p>Elixir est un langage fonctionnel qui tourne sur la VM Erlang mais ressemble
beaucoup à Ruby.</p>

<!-- more -->


<pre><code class="elixir">2 + 2
# =&gt; 4

IO.puts "Hello!"
# =&gt; Hello!
#    :ok

String.downcase("JE NE CRIE PAS")
# =&gt; "je ne crie pas"

defmodule Numbers do
  def add_to(num) do
    if is_number(num) do
      num + 2
    else
      raise(ArgumenError, message: "L'argument doit etre un nombre")
    end
  end
end

Numbers.add_to(4)
# =&gt; 6
Numbers.add_to("Nate")
# =&gt; ** (ArgumenError) L'argument doit etre un nombre
</code></pre>

<p>Elixir utilise la détection par motif (<em>pattern matching</em>) pour effectuer des
comparaisons et assigner des valeurs aux variables.</p>

<pre><code class="elixir">a = 2
# =&gt; 2

2 = a
# =&gt; 2

{ success, string } = { :ok, "Hey Joe, tu sais quoi ?" }
# =&gt; {:ok, "Hey Joe, tu sais quoi ?"}
success
# =&gt; :ok
string
# =&gt; "Hey Joe, tu sais quoi ?"
</code></pre>

<p>Elixir est fonctionnel, les variables sont donc immuables. Cependant,
contrairement à Erlang, ces dernières ne sont pas limitées à une seule
assignation. Si vous voulez détecter le motif de la valeur d'une variable, vous
devez utiliser un circonflexe <code>^</code>. Sans le circonflexe vous pouvez assigner une
nouvelle valeur à la variable.</p>

<pre><code class="elixir">a = 2
# =&gt; 2
^a = 3
# =&gt; ** (MatchError) aucune correspondance avec : 3
#    :erl_eval.expr/3
a = 3
# =&gt; 3
</code></pre>

<p>Comme tout langage fonctionnel, Elixir traite les fonctions comme des citoyens
de premier ordre. Vous pouvez assigner une fonction à une variable pour une
évaluation différée. Notez l'interpolation de chaîne dans l'exemple suivant,
une autre ressemblance à Ruby.</p>

<pre><code class="elixir">greeter = fn (name) -&gt; IO.puts "Hello #{name}" end
# =&gt; #Function&lt;6.80484245 in :erl_eval.expr/5&gt;
greeter.("Nate")
# =&gt; Hello Nate
#    :ok
</code></pre>

<p>Vous pouvez écrire des fonctions qui retournent des fonctions.</p>

<pre><code class="elixir">defmodule FunctionExamples do
  def build_greeter(kind) do
    case kind do
      :hello -&gt; fn (name) -&gt; "Coucou, #{name}!" end
      :goodbye -&gt; fn (name) -&gt; "A plus, #{name}!" end
      _ -&gt; fn (name) -&gt; "Je ne sais pas quoi te dire, #{name}." end
    end
  end
end

say_hello = FunctionExamples.build_greeter(:hello)
# =&gt; #Function&lt;0.63189797 in FunctionExamples.build_greeter/1&gt;
say_hello.("Nate")
# =&gt; Coucou, Nate!
#    :ok

wat = FunctionExamples.build_greeter(:something_else)
# =&gt; #Function&lt;2.63189797 in FunctionExamples.build_greeter/1&gt;
wat.("Nate")
# =&gt; "Je ne sais pas quoi te dire, Nate."
#    :ok
</code></pre>

<p>Comme dans d'autres langages fonctionnels, plutôt que de reposer sur des
boucles, Elixir utilise énormément la récursivité. Cela dit, le module <code>Enum</code>
fournit quelques fonctions bien connues des rubyists, comme <code>each</code> par exemple.</p>

<pre><code class="elixir">Enum.each(["Joe", "Matz", "Jose"], fn (name) -&gt; IO.puts(name) end)
# =&gt; Joe
# =&gt; Matz
# =&gt; Jose
# =&gt; :ok

defmodule RecursionExamples do
  def recurse([]) do
    :ok
  end
  def recurse([head|tail]) do
    IO.puts head
    recurse(tail)
  end
end

RecursionExamples.recurse(["Joe", "Matz", "Jose"])
# =&gt; Joe
# =&gt; Matz
# =&gt; Jose
# =&gt; :ok
</code></pre>

<p>C'est tout pour cette première partie. À bientôt pour <a href="/article/elixir-pour-les-rubyists-2">la deuxième</a>.</p>
]]></content>
  </entry>
  
</feed>
