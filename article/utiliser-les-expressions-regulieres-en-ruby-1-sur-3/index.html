


<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <title>Utiliser les Expressions Régulières en Ruby (1/3) · VF svp</title>
    <meta name="author" content="Simon Courtois (@simonc)" />
    <meta name="description" content="" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="canonical" href="
  http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3
" />
    <link rel="icon" href="/favicon.ico" />
    <link rel="stylesheet" href="/stylesheets/style.css" media="screen" />
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
    <link rel="alternate" href="/atom.xml" title="VF svp" type="application/atom+xml" />

    <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  </head>

  <body>
    <div class="navbar navbar-default navbar-static-top">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#menu">
        <span class="sr-only">Voir la navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand">VFsvp</a>
    </div>
    <div id="menu" class="collapse navbar-collapse navbar-right">
      <ul class="main-nav nav nav-pills">
        <li><a href="/">Blog</a></li>
        <li><a href="/blog/archives">Archives</a></li>
        <li>
          <a href="/atom.xml" rel="subscribe-rss" title="Suivre via RSS">
            <i class="fa fa-rss"></i> RSS
          </a>
        </li>
      </ul>
    </div>
  </div>
</div>


    <div class="container">
      <div class="row">
        <div class="col-sm-9">
          
<article class="article" role="article">
  <div class="row">
    <div class="col-sm-2">
      <p class="article-date">
        
          <span class="day">05/10</span>
          <span class="year">2013</span>
        
      </p>
      <p class="article-comments-count">
        <a href="#" title="Commentaires">0</a>
        <i class="fa fa-comment"></i>
      </p>
    </div>
    <div class="col-sm-10 article-body">
      <header>
        
          <h1 class="article-title">Utiliser les Expressions Régulières en Ruby (1/3)</h1>
          <div class="sharing">
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3" data-via="VFsvp" data-counturl="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3" >Tweet</a>
  <div class="g-plusone" data-size="medium" data-href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3"></div>
</div>

        
      </header>

      
        <div class="article-content"><p>Source: <a href="http://www.bluebox.net/about/blog/2013/02/using-regular-expressions-in-ruby-part-1-of-3/">Using Regular Expressions in Ruby de Nell Shamrell sur le blog de Blue Box</a></p>

<p>Voici la première partie d&#8217;une série sur les Expressions Régulières en Ruby.
Vous pouvez lire la
<a href="/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3">deuxième partie ici</a> et la
<a href="/article/utiliser-les-expressions-regulieres-en-ruby-3-sur-3">troisième partie ici</a>.</p>

<h2 id="introduction">Introduction</h2>

<p>Pour être honnête, la première fois que j&#8217;ai vu une expression régulière,
j&#8217;étais intimidée. Cela semblait si cryptique et mystérieux. Je peinais à voir
comment la comprendre et a fortiori en écrire une. Encore récemment, je
n&#8217;utilisais les expressions régulières qu&#8217;en cas d&#8217;absolue nécessité (une
validation d&#8217;email par ici, un remplacement basique par là). Cela m&#8217;a empêché
d&#8217;approfondir ma connaissance de leur utilisation en Ruby. Ruby travaille avec
les expressions régulière dans une harmonie, une symphonie de code. Pour
exploiter pleinement Ruby, je devais surpasser mon intimidation, ma peur des
expressions régulières.</p>

<p>J&#8217;ai dépassé cette peur. Comme toute chose dans la vie, les expressions
régulières semblent insurmontables jusqu&#8217;à ce qu&#8217;on les découpe. Je veux vous
aider à dépasser votre peur des expressions régulières. Pour cela, je vais les
découper, étape par étape, et vous guider au travers du concept d&#8217;expressions
régulières en Ruby et ce jusqu&#8217;aux techniques avancées. J&#8217;espère que vous verrez
la beauté, surpasserez votre intimidation et les adopterez dans votre code.</p>

<!-- more -->


<h2 id="les-expressions-regulieres">Les Expressions Régulières</h2>

<p>Une expression régulière est simplement un modèle. Un modèle auquel une chaîne
de caractères correspond ou non. Le livre <em>Programming Ruby 1.9</em> de Dave Thomas
(plus connu sous le nom <em>Pickaxe Book</em> [livre pic-à-glace]) regroupe en trois
catégories ce que l&#8217;on peut faire avec une expression régulière : tester,
extraire et modifier. Vous pouvez tester une chaîne de caractères pour voir si
elle correspond au modèle. Vous pouvez également modifier une chaîne de
caractères en remplaçant les parties correspondant au modèle par un autre texte.
Tester, extraire, modifier. Si simple et à la fois si puissant.</p>

<h2 id="les-expressions-regulieres-en-ruby">Les Expressions Régulières en Ruby</h2>

<p>Ruby vous permet de pousser les expressions régulières plus loin. En Ruby, tout
est objet. Cela inclus les expressions régulières. Vous pouvez envoyer des
messages aux objets, vous pouvez donc envoyer des messages aux expressions
régulières. Vous pouvez également les assigner à des variables, les passer à une
méthode et bien plus.</p>

<p>Depuis la version 1.9, Ruby utilise la bibliothèque d&#8217;expressions régulières
Oniguruma. Cette dernière fournit toutes les fonctionnalités standards des
expressions régulières ainsi qu&#8217;un certain nombre d&#8217;extensions. Elle supporte
parfaitement les caractères complexes comme les caractères japonais par exemple.
Une fonctionnalité que j&#8217;apprécie particulièrement est la possibilité d&#8217;utiliser
<code>\h</code> et <code>\H</code> comme raccourcis pour les chiffres hexadécimaux.</p>

<p>J&#8217;ai découvert récemment que Ruby 2.0 utilisait une bibliothèque différente,
Onigmo. Onigmo est un <em>fork</em> d&#8217;Oniguruma et ajoute encore plus de
fonctionnalités exploitables par Ruby. Il sera intéressant de voir jusqu&#8217;où cela
peut aller.</p>

<p>Malgré les modifications apportées par Onigmo, les fondamentaux de l&#8217;utilisation
des expressions régulières ne changent pas. Vous testez vos chaînes de
caractères avec une expression régulière. Vous composez un modèle auquel la
chaîne doit correspondre.</p>

<h2 id="test-basique">Test basique</h2>

<p>Dans la plupart des cas en Ruby, j&#8217;utilise l&#8217;opérateur <code>=~</code>. C&#8217;est l&#8217;opérateur
de test basique. Lorsque j&#8217;utilise cet opérateur, je demande à Ruby &ldquo;Est-ce que
cette chaîne de caractères contient ce modèle ?&rdquo;.</p>

<p>Voyons un premier exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="sr">/force/</span> <span class="o">=~</span> <span class="s2">&quot;Use the force&quot;</span>
</span></code></pre></div></figure>


<p>À gauche, on trouve une expression régulière qui représente le mot <em>force</em>. À
droite, une citation d&#8217;un de mes films préférés, Star Wars, &ldquo;Use the force&rdquo;.
Lorsque je lance ce code, je demande à Ruby si mon modèle, à gauche, est présent
dans la chaîne de caractères située à droite.</p>

<p>Détail appréciable, je peux en inverser l&#8217;écriture si je le souhaite.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;Use the force&quot;</span> <span class="o">=~</span> <span class="sr">/force/</span>
</span></code></pre></div></figure>


<p>Je peux mettre la chaîne à gauche et l&#8217;expression régulière à droite. Je fais le
même travail, simplement formulé autrement, &ldquo;Est-ce que ma chaîne contient mon
expression régulière ?&rdquo;. Certains trouvent cette formulation plus lisible.</p>

<p>Lorsque je lance ce code, il retourne le numéro du caractère auquel la
correspondance commence. Ici, le modèle <code>/force/</code> est trouvé au huitième
caractère de ma chaîne.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;Use the force&quot;</span> <span class="o">=~</span> <span class="sr">/force/</span>
</span><span class='line'><span class="c1">#=&gt; 8</span>
</span></code></pre></div></figure>


<p>Je peux également tester si une chaîne <strong>ne contient pas</strong> un modèle en
utilisant l&#8217;opérateur <code>!~</code>. Cela retourne vrai (<em>true</em>) ou faux (<em>false</em>).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="sr">/dark side/</span> <span class="o">!~</span> <span class="s2">&quot;Use the force&quot;</span>
</span></code></pre></div></figure>


<p>Si je lance ce code, je demande si l&#8217;expression <code>/dark side/</code> est absente de la
chaîne <code>"Use the force"</code>. Dans le cas présent, vrai est retourné.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="sr">/dark side/</span> <span class="o">!~</span> <span class="s2">&quot;Use the force&quot;</span>
</span><span class='line'><span class="c1">#=&gt; true</span>
</span></code></pre></div></figure>


<p>Les opérateurs sont parfaits pour la vérification simple, savoir si ma chaîne
correspond à mon expression régulière ou non paer exemple. Ruby fournit
cependant bien plus d&#8217;informations sur la correspondance. Tout ce que j&#8217;ai à
faire, c&#8217;est demander.</p>

<h2 id="matchdata">MatchData</h2>

<p>Le secret c&#8217;est de transformer ma correspondance en un objet <code>MatchData</code>. Je
peux créer cet objet avec la méthode <code>match</code>.</p>

<p>Soit la chaîne de caractères suivante :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;The force will be with you always&quot;</span>
</span></code></pre></div></figure>


<p>Je veux savoir si cette chaîne contient le mot <em>force</em>. Je peux utiliser
l&#8217;expression régulière suivante :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="sr">/force/</span>
</span></code></pre></div></figure>


<p>J&#8217;appelle la méthode <code>match</code> sur mon expression régulière et lui passe ma
chaîne. Lorsque je lance ce code, il retourne une instance de la classe
<code>MatchData</code> pour ma correspondance.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">my_match</span> <span class="o">=</span> <span class="sr">/force/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; #&lt;MatchData &quot;force&quot;&gt;</span>
</span></code></pre></div></figure>


<p>Depuis Ruby 1.9, la correspondance ne se fait plus obligatoirement au début de
la chaîne. Je peux passer un second argument, un entier, qui indique que la
correspondance doit commencer à partir de ce numéro de caractère.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">my_match</span> <span class="o">=</span> <span class="sr">/force/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; nil</span>
</span></code></pre></div></figure>


<p>Ici, le code retourne <code>nil</code>. Pour trouver une correspondance au mot <em>force</em>, il
faudrait commencer plus tôt dans la chaîne.</p>

<p>Pour les exemples suivants, je me contenterai de passer simplement ma chaîne de
caractères :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">my_match</span> <span class="o">=</span> <span class="sr">/force/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; #&lt;MatchData &quot;force&quot;&gt;</span>
</span></code></pre></div></figure>


<p>J&#8217;ai accès à des méthodes qui fournissent <strong>bien plus</strong> d&#8217;informations sur ma
correspondance car c&#8217;est maintenant une instance de la classe <code>MatchData</code>.</p>

<p>Si j&#8217;appelle <code>to_s</code> sur ma correspondance, cela va retourner l&#8217;intégralité de
son texte :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'><span class="c1">#=&gt; &quot;force&quot;</span>
</span></code></pre></div></figure>


<p>Si j&#8217;appelle <code>pre_match</code> dessus, cela retourne la partie de ma chaîne qui
<strong>précède</strong> ma correspondance :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">pre_match</span>
</span><span class='line'><span class="c1">#=&gt; &quot;The &quot;</span>
</span></code></pre></div></figure>


<p>Si j&#8217;appelle <code>post_match</code> dessus, cela retourne la partie de ma chaîne qui
<strong>suit</strong> ma correspondance :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">post_match</span>
</span><span class='line'><span class="c1">#=&gt; &quot; will be with you&quot;</span>
</span></code></pre></div></figure>


<p>Toutes ces méthodes (et il y en a d&#8217;autres) sont bien utiles. <code>MatchData</code>
montre cependant sa réelle utilité lorsque l&#8217;on parle de groupes de captures.
Les groupes de captures sont des sous expressions au sein d&#8217;une expression
régulière. Voici un exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="sr">/(.*)force(.*)/</span>
</span></code></pre></div></figure>


<p>Pour qu&#8217;une chaîne de caractères contienne cette expression régulière, elle doit
avoir n&#8217;importe quel caractère zéro, une ou plusieurs fois (c&#8217;est la
signification de <code>.*</code>), suivi du mot <em>force</em>, suivi par n&#8217;importe quel caractère
zéro, une ou plusieurs fois.</p>

<p>Notez bien que la première et la dernière partie de l&#8217;expression sont en entre
parenthèses. C&#8217;est ce qu&#8217;on appelle des groupes. Lorsque que je lance ce modèle
sur ma chaîne, ce qui correspond à ces groupes va être mémorisé. Je peux ensuite
accéder à ces groupes et les utiliser dans d&#8217;autres parties de mon code.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">my_match</span> <span class="o">=</span> <span class="sr">/(.*)force(.*)/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span></code></pre></div></figure>


<p>Si je souhaite voir tous ces groupes, mes groupes de captures, je peux appeler
la méthode <code>captures</code> sur ma correspondance.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">captures</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;The &quot;, &quot; will be with you always&quot;]</span>
</span></code></pre></div></figure>


<p>Les objets <code>MatchData</code> sont très proches des tableaux. Je peux accéder à
chaque capture en utilisant les crochets, de la même façon que pour accéder aux
éléments d&#8217;un tableau.</p>

<p>Si j&#8217;appelle <code>my_match[1]</code>, j&#8217;obtiens le premier groupe de capture, <code>"The "</code>.</p>

<p>De la même manière, <code>my_match[2]</code> retourne mon second groupe de captures, <code>"
will be with you always"</code>.</p>

<p>Notez bien que je ne commence pas avec <code>my_match[0]</code> comme je le ferais pour un
tableau classique. Si j&#8217;appelle <code>my_match[0]</code>, plutôt que de récupérer le
premier groupe, j&#8217;obtiens la chaîne sur laquelle j&#8217;ai lancé le modèle.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="c1">#=&gt; &quot;The force will be with you always&quot;</span>
</span></code></pre></div></figure>


<p>Il est important de garder en mémoire que malgré leur ressemblance avec les
tableaux, les objets <code>MatchData</code> ne sont pas des tableaux.</p>

<p>Si j&#8217;essaie d&#8217;appeler une méthode de tableau comme <code>each</code> sur mon objet
<code>MatchData</code>, j&#8217;obtiens une erreur :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
</span><span class='line'> <span class="nb">puts</span> <span class="n">m</span><span class="o">.</span><span class="n">upcase</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="c1">#=&gt; NoMethodError</span>
</span></code></pre></div></figure>


<p>Cependant, je peux facilement corriger cela en convertissant mon objet
<code>MatchData</code> en tableau grâce à la méthode <code>to_a</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
</span><span class='line'> <span class="nb">puts</span> <span class="n">m</span><span class="o">.</span><span class="n">upcase</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="c1">#=&gt; THE FORCE WILL BE WITH YOU ALWAYS THE WILL BE WITH YOU ALWAYS</span>
</span></code></pre></div></figure>


<p><a href="/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3">Lire le deuxième article de cette série</a></p>

<h2 id="lauteur-chez-blue-box">L&#8217;auteur chez Blue Box</h2>

<p>Nell Shamrell travaille chez Blue Box en tant qu&#8217;Ingénieur Développement
Logiciel. Elle siège également au conseil de Certification de Programmation
Ruby de l&#8217;Université de Washington et est spécialisée en Ruby, Rails et
Développement Dirigé par les Tests (TDD). Avant le développement, Nell a étudié
et travaillé dans le domaine du théâtre, une excellente préparation à
l&#8217;environnement dynamique de la création d&#8217;applications logicielles. Dans ces
deux mondes, elle s&#8217;efforce de créer une expérience unique. Sur son temps
libre, elle pratique l&#8217;art martial appelé Naginata.</p>
</div>

        <footer>
          <p class="meta">
            
  

<span class="byline author vcard">Posted by <span class="fn">Simon Courtois (simonc)</span></span>

            








  



  

<time datetime="2013-10-05T12:00:00+02:00" pubdate data-updated="true">05/10/2013</time>
            

<span class="categories">
  
    <a class='category' href='/tags/regex/'>regex</a>, <a class='category' href='/tags/ruby/'>ruby</a>
  
</span>


          </p>
          <p class="meta">
            
            
              <a class="basic-alignment right" href="/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3" title="Next Post: Utiliser les Expressions Régulières en Ruby (2/3)">Utiliser les Expressions Régulières en Ruby (2/3) &raquo;</a>
            
          </p>
        </footer>

        <section>
          <h1>Commentaires</h1>
          <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
        </section>
      
    </div>
  </div>
</article>


        </div>

        <aside class="sidebar col-sm-3">
          <section>
  <h1>VF svp</h1>
  <p>VF svp est un projet communautaire de traduction d'articles techniques.
    Pour proposer une traduction, rendez-vous sur
    <a href="http://github.com/simonc/vfsvp.fr" title="Page Github du projet VF svp">le Github du projet</a>.</p>
</section>
<section>
  <h1>Recherche</h1>
  <form role="search" action="http://google.com/search" method="get">
    <div class="form-group">
      <input type="hidden" name="q" value="site:vfsvp.fr" />
      <input type="text" name="q" results="0" class="form-control" placeholder="Rechercher..." />
    </div>
  </form>
</section>

<section>
  <h1>Twitter</h1>
  <p><a href="https://twitter.com/VFsvp">@VFsvp</a> sur Twitter</p>
</section>

<section>
  <h1>Sponsors</h1>
  <p>
    <a href="http://www.tinci.fr"><img src="/images/sponsors/tinci.png" alt="Tinci" /></a>
  </p>
</section>

        </aside>
      </div>
    </div>

    <footer class="text-center">
      <footer role="contentinfo">
  <p>Copyright © 2014 - Simon Courtois (@simonc) -
    <span class="credit">Publié grâce à
    <a href="http://octopress.org">Octopress</a></span></p>
</footer>

    </footer>
    <script type="text/javascript">
  var disqus_shortname = 'vfsvp';

  
    var disqus_identifier = 'http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3';
    var disqus_url = 'http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3';
    var disqus_script = 'embed.js';
  

  (function () {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
</script>


  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>



  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-15419839-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>

  </body>
</html>
