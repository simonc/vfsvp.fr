


<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <title>Les méthodes pack et unpack en Ruby · VF svp</title>
    <meta name="author" content="Simon Courtois (@simonc)" />
    <meta name="description" content="" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="canonical" href="
  http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby
" />
    <link rel="icon" href="/favicon.ico" />
    <link rel="stylesheet" href="/stylesheets/style.css" media="screen" />
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
    <link rel="alternate" href="/atom.xml" title="VF svp" type="application/atom+xml" />

    <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  </head>

  <body>
    <div class="navbar navbar-default navbar-static-top">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#menu">
        <span class="sr-only">Voir la navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand">VFsvp</a>
    </div>
    <div id="menu" class="collapse navbar-collapse navbar-right">
      <ul class="main-nav nav nav-pills">
        <li><a href="/">Blog</a></li>
        <li><a href="/blog/archives">Archives</a></li>
        <li>
          <a href="/atom.xml" rel="subscribe-rss" title="Suivre via RSS">
            <i class="fa fa-rss"></i> RSS
          </a>
        </li>
      </ul>
    </div>
  </div>
</div>


    <div class="container">
      <div class="row">
        <div class="col-sm-9">
          
<article class="article" role="article">
  <div class="row">
    <div class="col-sm-2">
      <p class="article-date">
        
          <span class="day">07/10</span>
          <span class="year">2013</span>
        
      </p>
      <p class="article-comments-count">
        <a href="#" title="Commentaires">0</a>
        <i class="fa fa-comment"></i>
      </p>
    </div>
    <div class="col-sm-10 article-body">
      <header>
        
          <h1 class="article-title">Les méthodes pack et unpack en Ruby</h1>
          <div class="sharing">
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby" data-via="VFsvp" data-counturl="http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby" >Tweet</a>
  <div class="g-plusone" data-size="medium" data-href="http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby"></div>
</div>

        
      </header>

      
        <div class="article-content"><p>Source: <a href="http://blog.bigbinary.com/2011/07/20/ruby-pack-unpack.html">Ruby Pack Unpack de Neeraj Singh sur le blog de BigBinary</a></p>

<p>Le langage C permet aux développeurs d&#8217;accéder directement à la mémoire où sont
stockées les variables. Ruby ne le permet pas. Il est cependant des cas dans
lesquels on peut avoir besoin d&#8217;accéder aux bits et octets contenus dans cette
mémoire tout en travaillant avec Ruby. Ce dernier fournit deux méthods <code>pack</code> et
<code>unpack</code> pour cela.</p>

<p>Voici un exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s1">&#39;A&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;b*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;10000010&quot;]</span>
</span></code></pre></div></figure>




<!-- more -->


<p>Dans le cas ci-dessus, <code>'A'</code> est une chaîne de caractères stockée et, grâce à
<code>unpack</code> je tente d&#8217;en lire la valeur binaire. La table ASCII indique que la
valeur de <code>'A'</code> est 65 et la représentation binaire de 65 est <code>10000010</code>.</p>

<p>Un autre exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s1">&#39;A&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;B*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;01000001&quot;]</span>
</span></code></pre></div></figure>


<p>Notez bien le changement de résultat entre les deux exemples. Quelle est la
différence entre <code>b*</code> et <code>B*</code> ? Pour le comprendre nous devons d&#8217;abord parler
de <em>MSB</em> et <em>LSB</em>.</p>

<h2 id="bit-de-poids-fort-et-bit-de-poids-faible">Bit de poids fort et bit de poids faible</h2>

<p>Tous les bits ne sont pas créés égaux. <code>'C'</code> a la valeur ASCII 67. La
représentation binaire de 67 est <code>1000011</code>.</p>

<p>Parlons d&#8217;abord du style <em>MSB</em> (most significant bit, bit de poids fort). Si
vous utilisez le style <em>MSB</em>, et lisez donc de gauche à droite (en lisant tout
le temps de gauche à droite), le bit de poids le plus fort est donc le premier.
Puisque le bit de poids le plus fort vient en premier, nous pouvons ajouter un
<code>0</code> devant pour obtenir huit bits. Après avoir ajouté un <code>0</code> la représentation
binaire est donc <code>01000011</code>.</p>

<p>Pour convertir cette valeur en <em>LSB</em> (least significant bit, bit de poids
faible), nous devons stocker le bit de poids faible en premier (à gauche). Nous
pouvons voir ci-dessous comment les bits vont être déplacés lors de la
convertion de <em>MSB</em> vers <em>LSB</em>. Notez qu&#8217;ici la position 1 indique le bit le
plus à gauche.</p>

<ul>
<li>déplacer la valeur 1 de la position <em>MSB</em> 8 à la position <em>LSB</em> 1</li>
<li>déplacer la valeur 1 de la position <em>MSB</em> 7 à la position <em>LSB</em> 2</li>
<li>déplacer la valeur 0 de la position <em>MSB</em> 6 à la position <em>LSB</em> 3</li>
<li>et ainsi de suite</li>
</ul>


<p>Une fois l&#8217;exercice terminé, la valeur sera <code>11000010</code>.</p>

<p>Nous avons effectué cette transformation à la main pour bien comprendre la
différence entre bit de poids fort et bit de poids faible. La méthode <code>unpack</code>
est cependant capable de donner les deux représentations. Cette méthode peut
prendre <code>b*</code> ou <code>B*</code> en entrée, voici leur différence selon la documentation de
Ruby :</p>

<pre><code>B | bit string (MSB first) | représentation binaire (bit de poids fort en premier)
b | bit string (LSB first) | représentation binaire (bit de poids faible en
</code></pre>

<p>Voyons maintenant deux exemples.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s1">&#39;C&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;b*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;11000010&quot;]</span>
</span><span class='line'>
</span><span class='line'><span class="s1">&#39;C&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;B*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;01000011&quot;]</span>
</span></code></pre></div></figure>


<p><code>b*</code> et <code>B*</code> voient tous les deux là même donnée. Ils représentent simplement
cette donnée différemment.</p>

<h2 id="differentes-facons-de-representer-une-meme-donnee">Différentes façons de représenter une même donnée</h2>

<p>Disons que je souhaite la représentation binaire de la chaîne <code>hello</code>. D&#8217;après
ce que nous avons vu précédemment cela devrait être assez facile :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;B*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;0110100001100101011011000110110001101111&quot;]</span>
</span></code></pre></div></figure>


<p>Nous pouvons également obtenir le résultat suivant</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">to_s</span> <span class="mi">2</span><span class="p">}</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;1101000&quot;, &quot;1100101&quot;, &quot;1101100&quot;, &quot;1101100&quot;, &quot;1101111&quot;]</span>
</span></code></pre></div></figure>


<p>Voyons un exemple similaire mais en découpant les étapes cette fois.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></div></figure>


<p>La directive <code>C*</code> retourne les caractères sous la forme d&#8217;un entier non signé
tenant sur 8 bits. On peut voir que la valeur ASCII de <code>h</code> est 104 et celle de
<code>e</code> est 101, etc.</p>

<p>En utilisant la technique vu précédemment, nous pouvons obtenir une
représentation hexadécimale de notre chaîne :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">to_s</span> <span class="mi">16</span><span class="p">}</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;68&quot;, &quot;65&quot;, &quot;6c&quot;, &quot;6c&quot;, &quot;6f&quot;]</span>
</span></code></pre></div></figure>


<p>Il est toutefois possible d&#8217;obtenir directement cette valeur hexadécimale :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;H*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;68656c6c6f&quot;]</span>
</span></code></pre></div></figure>


<h2 id="high-nibble-first-vs-low-nibble-first">High nibble first vs Low nibble first</h2>

<p>Observez la différence entre les deux cas suivants :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;H*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;68656c6c6f&quot;]</span>
</span><span class='line'>
</span><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;h*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;8656c6c6f6&quot;]</span>
</span></code></pre></div></figure>


<p>La documentation Ruby indique</p>

<pre><code>H | hex string (high nibble first) | représentation hexadécimale (moitié haute en premier)
h | hex string (low nibble first)  | représentation hexadécimale (moitié basse en premier)
</code></pre>

<p>Un octet est composé de 8 bits. Une moitié contient donc 4 bits. Un octet
donc deux moitiés. La valeur ASCII de <code>h</code> est 104. 104 en hexadécimale s&#8217;écrit
68. Ce nombre 68 est stocké en deux moitiés. La première contient la valeur 6
sur 4 bits et la seconde contient la valeur 8. En général on utilise la notation
moitié haute puis moitié basse, de gauche à droite, la valeur 6 pour la
valeur 8.</p>

<p>Si cependant vous devez utiliser la notation moitié basse puis moitié haute, la
valeur 8 prendra la première place suivie de la valeur 6. La notation <em>moitié
basse en premier</em> donne donc 86.</p>

<p>Cette notation est utilisée pour chaque octet. Pour cette raison, la version
<em>moitié basse en premier</em> de <code>68 65 6c 6c 6f</code> est <code>86 56 c6 c6 f6</code>.</p>

<h2 id="melanger-les-directives">Mélanger les directives</h2>

<p>Dans les exemples précédents, nous avons utilisé le caractère <code>*</code>. Cela indique
de traiter autant de caractères que possible. Par exemple :</p>

<p>A single C will get a single byte.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104]</span>
</span></code></pre></div></figure>


<p>Vous pouvez ajouter plus de <code>C</code> si vous le souhaitez.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;CC&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101]</span>
</span><span class='line'>
</span><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;CCC&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108]</span>
</span><span class='line'>
</span><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;CCCCC&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></div></figure>


<p>Plutôt que de répéter ces directives, nous pouvons utiliser un nombre pour
indiquer combien de fois la directive doit être répétée.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C5&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></div></figure>


<p>Nous pouvons utiliser <code>*</code> pour capturer toutes les octets restants.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></div></figure>


<p>Voyons un exemple dans lequel nous mélangeons les notations <em>MSB</em> et <em>LSB</em> :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;aa&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;b8B8&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;10000110&quot;, &quot;01100001&quot;]</span>
</span></code></pre></div></figure>


<h2 id="pack-est-linverse-de-unpack">pack est l&#8217;inverse de unpack</h2>

<p>La méthode <code>pack</code> est utilisée pour lire les données stockées. Voyons quelques
exemples d&#8217;utilisation :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="mi">1000001</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;A&quot;</span>
</span></code></pre></div></figure>


<p>Dans le code ci-dessus, le valeur binaire est interpretée comme un entier non
signé sur 8 bits et le résultat est <code>'A'</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s1">&#39;A&#39;</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;\xA0&quot;</span>
</span></code></pre></div></figure>


<p>Ici, l&#8217;entrée <code>'A'</code> n&#8217;est pas le <code>A</code> ASCII mais le <code>A</code> hexadécimale. C&#8217;est
la version hexadécimale à cause de la directive <code>H</code>. Cette dernière indique à
<code>pack</code> de traiter l&#8217;entrée comme une valeur hexadécimale. Comme <code>H</code> utilise la
notation <em>moitié haute en premier</em>, puisque l&#8217;entrée ne contient qu&#8217;une moitié,
cela signifie que la deuxième moitié, la moitié basse, a la valeur <code>0</code>. L&#8217;entrée
est donc vue comme <code>'A0'</code>.</p>

<p>Comme la valeur hexadécimale <code>A0</code> ne correspond à rien dans la table ASCII, le
résultat final est laissé tel quel et vaut donc <code>'\xA0'</code>. Le préfix <code>\x</code> indique
qu&#8217;il s&#8217;agit d&#8217;une valeur hexadécimale.</p>

<p>En hexadécimale, <code>a</code> a la même valeur que <code>A</code>. Nous pouvons donc remplacer <code>A</code>
par <code>a</code> dans notre exemple précédent et le résultat reste inchangé. Essayons
pour voir :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s1">&#39;a&#39;</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;\xA0&quot;</span>
</span></code></pre></div></figure>


<p>Un autre exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s1">&#39;a&#39;</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;\n&quot;</span>
</span></code></pre></div></figure>


<p>Dans le code ci-dessus, il y a une différence notable dans le résultat. Nous
avons changé la directive de <code>H</code> à <code>h</code>. Comme <code>h</code> indique d&#8217;utiliser la notation
<em>moitié basse en premier</em> et que l&#8217;entrée ne contient qu&#8217;une moitié, la moitié
basse vaut <code>0</code> et l&#8217;entrée est donc <code>0a</code>. Le résultat est <code>\x0A</code> et si l&#8217;on
regarde dans la table ASCII, <code>0A</code> vaut 10 et le caractère correspondant est
<code>NL</code>, <em>new line</em> soit un saut de ligne. C&#8217;est pour cela que nous voyons
s&#8217;afficher <code>\n</code> qui représente un saut de ligne.</p>

<h2 id="utilisation-de-unpack-dans-le-code-de-rails">Utilisation de unpack dans le code de Rails</h2>

<p>J&#8217;ai cherché un peu dans le code source de Rails et trouvé les utilisations
suivantes de la méthode <code>unpack</code> :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">email_address_obfuscated</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="s1">&#39;mailto:&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">email_address</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">char</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;H2&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">column</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">string_to_binary</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;H*&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">data</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;U*&quot;</span><span class="p">)</span>
</span></code></pre></div></figure>


<p>Nous avons déjà vu les directives <code>C*</code> et <code>H</code>, les directives <code>m</code> et <code>U</code> sont
cependant nouvelles. La première sert à donner une représentation encodée en
base64 de la valeur, la seconde retourne le caractère UTF-8 correspondant. Voici
un exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="s2">&quot;Hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [72, 101, 108, 108, 111]</span>
</span></code></pre></div></figure>


<h2 id="versions-de-test">Versions de test</h2>

<p>Les exmples de code précédents ont été testés avec la version <em>1.9.2</em> de Ruby.</p>

<p>NDT: J&#8217;ai testé avec les versions 1.9.3 et 2.0.0, les exemples sont toujours
valides.</p>
</div>

        <footer>
          <p class="meta">
            
  

<span class="byline author vcard">Posted by <span class="fn">Simon Courtois (simonc)</span></span>

            








  



  

<time datetime="2013-10-07T10:00:00+02:00" pubdate data-updated="true">07/10/2013</time>
            

<span class="categories">
  
    <a class='category' href='/tags/rails/'>rails</a>, <a class='category' href='/tags/ruby/'>ruby</a>
  
</span>


          </p>
          <p class="meta">
            
              <a class="basic-alignment left" href="/article/utiliser-les-expressions-regulieres-en-ruby-3-sur-3" title="Previous Post: Utiliser les Expressions Régulières en Ruby (3/3)">&laquo; Utiliser les Expressions Régulières en Ruby (3/3)</a>
            
            
              <a class="basic-alignment right" href="/article/6-facons-de-reduire-la-souffrance-des-tests-fonctionnels-avec-Rails" title="Next Post: 6 façons de réduire la souffrance due aux tests fonctionnels avec Rails">6 façons de réduire la souffrance due aux tests fonctionnels avec Rails &raquo;</a>
            
          </p>
        </footer>

        <section>
          <h1>Commentaires</h1>
          <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
        </section>
      
    </div>
  </div>
</article>


        </div>

        <aside class="sidebar col-sm-3">
          <section>
  <h1>VF svp</h1>
  <p>VF svp est un projet communautaire de traduction d'articles techniques.
    Pour proposer une traduction, rendez-vous sur
    <a href="http://github.com/simonc/vfsvp.fr" title="Page Github du projet VF svp">le Github du projet</a>.</p>
</section>
<section>
  <h1>Recherche</h1>
  <form role="search" action="http://google.com/search" method="get">
    <div class="form-group">
      <input type="hidden" name="q" value="site:vfsvp.fr" />
      <input type="text" name="q" results="0" class="form-control" placeholder="Rechercher..." />
    </div>
  </form>
</section>

<section>
  <h1>Twitter</h1>
  <p><a href="https://twitter.com/VFsvp">@VFsvp</a> sur Twitter</p>
</section>

<section>
  <h1>Sponsors</h1>
  <p>
    <a href="http://www.tinci.fr"><img src="/images/sponsors/tinci.png" alt="Tinci" /></a>
  </p>
</section>

        </aside>
      </div>
    </div>

    <footer class="text-center">
      <footer role="contentinfo">
  <p>Copyright © 2014 - Simon Courtois (@simonc) -
    <span class="credit">Publié grâce à
    <a href="http://octopress.org">Octopress</a></span></p>
</footer>

    </footer>
    <script type="text/javascript">
  var disqus_shortname = 'vfsvp';

  
    var disqus_identifier = 'http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby';
    var disqus_url = 'http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby';
    var disqus_script = 'embed.js';
  

  (function () {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
</script>


  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>



  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-15419839-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.1.0.1/js/bootstrap.min.js"></script>

  </body>
</html>
