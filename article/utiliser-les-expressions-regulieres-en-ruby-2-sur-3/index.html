


<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <title>Utiliser les Expressions Régulières en Ruby (2/3) · VF svp</title>
    <meta name="author" content="Simon Courtois (@simonc)" />
    <meta name="description" content="" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="canonical" href="
  http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3
" />
    <link rel="icon" href="/favicon.ico" />
    <link rel="stylesheet" href="/stylesheets/style.css" media="screen" />
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
    <link rel="alternate" href="/atom.xml" title="VF svp" type="application/atom+xml" />

    <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  </head>

  <body>
    <div class="navbar navbar-default navbar-static-top">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#menu">
        <span class="sr-only">Voir la navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand">VFsvp</a>
    </div>
    <div id="menu" class="collapse navbar-collapse navbar-right">
      <ul class="main-nav nav nav-pills">
        <li><a href="/">Blog</a></li>
        <li><a href="/blog/archives">Archives</a></li>
        <li>
          <a href="/atom.xml" rel="subscribe-rss" title="Suivre via RSS">
            <i class="fa fa-rss"></i> RSS
          </a>
        </li>
      </ul>
    </div>
  </div>
</div>


    <div class="container">
      <div class="row">
        <div class="col-sm-9">
          
<article class="article" role="article">
  <div class="row">
    <div class="col-sm-2">
      <p class="article-date">
        
          <span class="day">05/10</span>
          <span class="year">2013</span>
        
      </p>
      <p class="article-comments-count">
        <a href="#" title="Commentaires">0</a>
        <i class="fa fa-comment"></i>
      </p>
    </div>
    <div class="col-sm-10 article-body">
      <header>
        
          <h1 class="article-title">Utiliser les Expressions Régulières en Ruby (2/3)</h1>
          <div class="sharing">
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3" data-via="VFsvp" data-counturl="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3" >Tweet</a>
  <div class="g-plusone" data-size="medium" data-href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3"></div>
</div>

        
      </header>

      
        <div class="article-content"><p>Source: <a href="http://www.bluebox.net/about/blog/2013/03/using-regular-expressions-in-ruby-part-2-of-3/">Using Regular Expressions in Ruby de Nell Shamrell sur le blog de Blue Box</a></p>

<p>Voici la seconde partie dans une série sur les Expressions Régulières en Ruby.
Vous pouvez lire la
<a href="/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3">première partie ici</a> et la
<a href="/article/utiliser-les-expressions-regulieres-en-ruby-3-sur-3">troisième partie ici</a>.</p>

<h2 id="les-lookarounds">Les LookArounds</h2>

<p>Les lookarounds me permettent d&#8217;aller plus loin que la simple comparaison avec
un modèle. En effet, ils offrent la possibilité de donner un contexte à cette
comparaison. Une expression contenant un lookaround ne retourne un résultat que
lorsqu&#8217;elle est effectuée dans ce contexte.</p>

<!-- more -->


<p>Soit une nouvelle chaîne de caractère, une autre citation d&#8217;Obiwan Kenobi dans
Star Wars.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Who&#39;s the more foolish?  The fool or the fool who follows him?&quot;</span>
</span></code></pre></div></figure>


<p>Je veux connaître tous les emplacements du mot &ldquo;fool&rdquo; dans cette chaîne. Je vais
donc utiliser l&#8217;expression régulière <code>/fool/</code>. Dans ce cas précis, je vais
utiliser la méthode <code>scan</code> sur ma chaîne. Cette méthode retourne toutes les
occurrences de mon expression dans la chaîne :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/fool/</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;fool&quot;, &quot;fool&quot;, &quot;fool&quot;]</span>
</span></code></pre></div></figure>


<p>Comme on peut le voir, scan retourne une partie du mot &ldquo;foolish&rdquo; et les deux
occurrences du mot &ldquo;fool&rdquo;.</p>

<p>Comment fait-on si l&#8217;on souhaite que notre modèle <code>/fool/</code> retourne un résultat
seulement s&#8217;il fait partie du mot &ldquo;foolish&rdquo; ? Pour ce cas j&#8217;utiliserais un
<em>lookahead positif</em> (recherche vers l&#8217;avant). Cela indique à mon expression
régulière de trouver toutes les correspondances à mon modèle directement suivies
d&#8217;une correspondance à un autre modèle. En Ruby, un lookahead positif est
exprimé grâce à l&#8217;opérateur <code>?=</code> :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="sr">/fool(?=ish)/</span>
</span></code></pre></div></figure>


<p>Voici mon expression modifiée. Comme vous pouvez le voir, j&#8217;ai mon modèle
contenant le mot &ldquo;fool&rdquo; directement suivi du modèle lookahead &ldquo;ish&rdquo;.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/fool(?=ish)/</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;=&gt;</span> <span class="o">[</span><span class="s2">&quot;fool&quot;</span><span class="o">]</span>
</span></code></pre></div></figure>


<p>Cette fois-ci, la méthode <code>scan</code> retourne un seul résultat, la seule occurrence
de &ldquo;fool&rdquo; suivie de &ldquo;ish&rdquo;.</p>

<p>De nouveau, utilisons la méthode <code>gsub</code> pour modifier notre chaîne. Remplaçons
chaque occurrence de &ldquo;fool&rdquo; (suivie de &ldquo;ish&rdquo;) par le mot &ldquo;self&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/fool(?=ish)/</span><span class="p">,</span> <span class="s2">&quot;self&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;Who&#39;s the more selfish?  The fool or the fool who follows him?&quot;</span>
</span></code></pre></div></figure>


<p>Nos excuses à Obiwan Kenobi, nous avons changé la ligne pour <em>&ldquo;Who&rsquo;s the more
selfish?  The fool or the fool who follows him?&rdquo;</em>.</p>

<p>Techniquement, c&#8217;est ce que l&#8217;on appelle une <em>zero-width, positive lookahead
assertion</em> (recherche positive vers l&#8217;avant de taille zéro). Facile à prononcer
n&#8217;est-ce pas ? Dans le livre <em>The Well Grounded Rubyist</em>, David Black
l&#8217;explique comme ceci :</p>

<dl>
<dt>Zero-width</dt>
<dd>   (taille zéro) signifie que le modèle lookahead (&ldquo;ish&rdquo; dans notre cas) ne
   consomme pas de caractères. Cela veut dire que la correspondance est
   cherchée mais n&#8217;est pas retournée. Seule la présence d&#8217;une correspondance
   est retournée, vrai ou faux.</dd>
<dt>Positive</dt>
<dd>   signifie que le modèle doit être présent, obligatoirement.</dd>
<dt>Lookahead</dt>
<dd>   veut dire que cette expression est recherchée après le modèle principal.</dd>
<dt>Assertion</dt>
<dd>   indique que seule la présence d&#8217;une correspondance est retournée sous la
   forme true/false (vrai/faux).</dd>
</dl>

<p>Quelles sont mes autres possibilité ? Si par exemple je souhaite trouver toutes
les occurrences du mot &ldquo;fool&rdquo; qui ne sont <strong>pas</strong> suivies des lettres &ldquo;ish&rdquo; ?
Dans ce cas, je dois utiliser un lookahead négatif. Techniquement, c&#8217;est ce que
l&#8217;on appelle une <em>zero-width, negative lookahead assertion</em> (recherche négative
vers l&#8217;avant de taille zéro). Négative signifie qu&#8217;aucune correspondance à ce
modèle ne doit être trouvée. Pour effectuer un lookahead négatif, uilisez
l&#8217;opérateur <code>?!</code>.</p>

<p>Je vais de nouveau appeler <code>scan</code> sur ma chaîne en utilisant cette fois un
lookahead négatif dans mon expression régulière. Je veux trouver toutes les
occurrences de &ldquo;fool&rdquo; qui ne font pas partie du mot &ldquo;foolish&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/fool(?!ish)/</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;fool&quot;, &quot;fool&quot;]</span>
</span></code></pre></div></figure>


<p>Deux correspondances sont retournées, les deux fois où le mot &ldquo;fool&rdquo; apparait
sans faire partie de &ldquo;foolish&rdquo;.</p>

<p>Utilisons maintenant la méthode <code>gsub</code>. À chaque fois que nous
trouvons le mot &ldquo;fool&rdquo; (non suivi des lettres &ldquo;ish&rdquo;), nous allons le remplacer
pas le mot &ldquo;self&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/fool(?!ish)/</span><span class="p">,</span> <span class="s2">&quot;self&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;Who&#39;s the more foolish?  The self or the self who follows him?&quot;</span>
</span></code></pre></div></figure>


<p>Encore une fois j&#8217;ai changé une réplique classique. On peut maintenant lire
&ldquo;Who&rsquo;s the more foolish?  The self or the self who follows him?&rdquo;</p>

<p>Les lookaheads sont très pratiques lorsque l&#8217;on souhaite trouver une
correspondance en prenant en compte ce qui la suit. Allons de nouveau un peu
plus loin. Comment dois-je m&#8217;y prendre si je souhaite trouver une correspondance
à partir de ce qui la précède ? Pour faire cela, je dois utiliser une <em>positive
lookbehind assertion</em> (recherche positive vers l&#8217;arrière). Cela signifie que je
veux trouver toutes les correspondances à mon modèle précédées d&#8217;un autre
modèle.</p>

<p>Utilisons une autre citation de Star Wars, une de Yoda cette fois-ci :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;For my ally is the force, and a powerful ally it is.&quot;</span>
</span></code></pre></div></figure>


<p>The modèle principal que je souhaite chercher est le mot &ldquo;ally&rdquo;, je vais donc
utiliser l&#8217;expression régulière <code>/ally/</code>. J&#8217;aimerais cependant trouver le mot
&ldquo;ally&rdquo; uniquement s&#8217;il est directement précédé du mot &ldquo;powerful&rdquo;. C&#8217;est le cas
parfait pour un <em>positive lookbehind</em> (recherche positive vers l&#8217;arrière). Les
lookbehinds positifs utilisent l&#8217;opérateur <code>?&lt;=</code>. Utilisons le dans notre
expression régulière :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="sr">/(?&lt;=powerful )ally/</span>
</span></code></pre></div></figure>


<p>Cette expression régulière relève le mot &ldquo;ally&rdquo; chaque fois qu&#8217;il est
directement précédé du mot &ldquo;powerful&rdquo;. Comme vous pouvez le remarquer, le
lookbehind est positionné avant le modèle principal. Cela montre bien que le mot
&ldquo;powerful&rdquo; doit est devant le mot &ldquo;ally&rdquo;.</p>

<p>Je vais maintenant utiliser la méthode <code>gsub</code> sur ma chaîne. Chaque fois que le
mot &ldquo;ally&rdquo; est précédé par le mot &ldquo;powerful&rdquo;, je veux le remplacer par le mot
&ldquo;friend&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/(?&lt;=powerful )ally/</span><span class="p">,</span> <span class="s2">&quot;friend&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; For my ally is the force, and a powerful friend it is.</span>
</span></code></pre></div></figure>


<p>Cela change quelque peu les mots de Yoda : &ldquo;For my ally is the force, and a
powerful friend it is.&rdquo;</p>

<p>Comment dois-je m&#8217;y prendre si je souhaite faire le contraire ? Si par exemple
je veux toutes les occurrences du mot &ldquo;ally&rdquo; qui ne sont <strong>pas</strong> précédées du
mot &ldquo;powerful&rdquo;. Dans ce cas, je dois utiliser un <em>negative lookbehind</em>
(recherche négative vers l&#8217;arrière). Pour cela on trouve l&#8217;opérateur <code>?&lt;!</code>.
Utilisons-le dans notre expression régulière :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="sr">/(?&lt;!powerful )ally/</span>
</span></code></pre></div></figure>


<p>Utilisons maintenant <code>gsub</code> sur notre chaîne pour remplacer chaque occurence du
mot &ldquo;ally&rdquo;, non précédée du mot &ldquo;powerful&rdquo;, par le mot &ldquo;friend&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/(?&lt;!powerful )ally/</span><span class="p">,</span> <span class="s2">&quot;friend&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;For my friend is the force, and a powerful ally it is.&quot;</span>
</span></code></pre></div></figure>


<p>J&#8217;ai de nouveau changé les paroles de Yoda : &ldquo;For my ally is the force, and a
powerful friend it is.&rdquo;.</p>

<p>Les lookarounds donnent une puissance incroyable à vos expressions régulières en
leur apportant un contexte. Plutôt que d&#8217;utiliser un modèle strict qui
correspond ou non, vos expressions régulières deviennent puissantes, flexibles
et capables de trouver bien plus de choses.</p>

<p><a href="/article/utiliser-les-expressions-regulieres-en-ruby-3-sur-3">Lire le troisième article de cette série</a></p>

<h2 id="lauteur-chez-blue-box">L&#8217;auteur chez Blue Box</h2>

<p>Nell Shamrell travaille chez Blue Box en tant qu&#8217;Ingénieur Développement
Logiciel. Elle siège également au conseil de Certification de Programmation
Ruby de l&#8217;Université de Washington et est spécialisée en Ruby, Rails et
Développement Dirigé par les Tests (TDD). Avant le développement, Nell a étudié
et travaillé dans le domaine du théâtre, une excellente préparation à
l&#8217;environnement dynamique de la création d&#8217;applications logicielles. Dans ces
deux mondes, elle s&#8217;efforce de créer une expérience unique. Sur son temps
libre, elle pratique l&#8217;art martial appelé Naginata.</p>
</div>

        <footer>
          <p class="meta">
            
  

<span class="byline author vcard">Posted by <span class="fn">Simon Courtois (simonc)</span></span>

            








  



  

<time datetime="2013-10-05T12:00:00+02:00" pubdate data-updated="true">05/10/2013</time>
            

<span class="categories">
  
    <a class='category' href='/tags/regex/'>regex</a>, <a class='category' href='/tags/ruby/'>ruby</a>
  
</span>


          </p>
          <p class="meta">
            
              <a class="basic-alignment left" href="/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3" title="Previous Post: Utiliser les Expressions Régulières en Ruby (1/3)">&laquo; Utiliser les Expressions Régulières en Ruby (1/3)</a>
            
            
              <a class="basic-alignment right" href="/article/utiliser-les-expressions-regulieres-en-ruby-3-sur-3" title="Next Post: Utiliser les Expressions Régulières en Ruby (3/3)">Utiliser les Expressions Régulières en Ruby (3/3) &raquo;</a>
            
          </p>
        </footer>

        <section>
          <h1>Commentaires</h1>
          <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
        </section>
      
    </div>
  </div>
</article>


        </div>

        <aside class="sidebar col-sm-3">
          <section>
  <h1>VF svp</h1>
  <p>VF svp est un projet communautaire de traduction d'articles techniques.
    Pour proposer une traduction, rendez-vous sur
    <a href="http://github.com/simonc/vfsvp.fr" title="Page Github du projet VF svp">le Github du projet</a>.</p>
</section>
<section>
  <h1>Recherche</h1>
  <form role="search" action="http://google.com/search" method="get">
    <div class="form-group">
      <input type="hidden" name="q" value="site:vfsvp.fr" />
      <input type="text" name="q" results="0" class="form-control" placeholder="Rechercher..." />
    </div>
  </form>
</section>

<section>
  <h1>Twitter</h1>
  <p><a href="https://twitter.com/VFsvp">@VFsvp</a> sur Twitter</p>
</section>

<section>
  <h1>Sponsors</h1>
  <p>
    <a href="http://www.tinci.fr"><img src="/images/sponsors/tinci.png" alt="Tinci" /></a>
  </p>
</section>

        </aside>
      </div>
    </div>

    <footer class="text-center">
      <footer role="contentinfo">
  <p>Copyright © 2014 - Simon Courtois (@simonc) -
    <span class="credit">Publié grâce à
    <a href="http://octopress.org">Octopress</a></span></p>
</footer>

    </footer>
    <script type="text/javascript">
  var disqus_shortname = 'vfsvp';

  
    var disqus_identifier = 'http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3';
    var disqus_url = 'http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3';
    var disqus_script = 'embed.js';
  

  (function () {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
</script>


  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>



  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-15419839-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



  </body>
</html>
